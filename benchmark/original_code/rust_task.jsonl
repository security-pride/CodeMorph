{"task_id": "rust_1", "code": "use std::cmp;\nuse std::fs::File;\nuse std::io::{BufReader, BufRead, Read};\n\nfn is_symbol(ch: u8) -> bool {\n    b'!' <= ch && ch <= b'~'\n}\n\nfn is_alpha(ch: u8) -> bool {\n    (b'a' <= ch && ch <= b'z') || (b'A' <= ch && ch <= b'Z')\n}\n\nfn to_ascii(v: &Vec<u8>) -> String {\n    let mut s = String::with_capacity(v.len());\n\n    for &ch in v.iter() {\n        s.push(if is_symbol(ch) {ch} else {b'_'} as char);\n    }\n\n    s\n}\n\nfn hex_to_u8(a: u8) -> u8 {\n    match a {\n        b'0'...b'9' => a - b'0',\n        b'a'...b'h' => a - b'a' + 10,\n        _           => 0\n    }\n}\n\nfn vec_u8_from_hex_string(s: &String) -> Vec<u8> {\n    s.as_bytes().chunks(2).map(|a| hex_to_u8(a[0]) * 16 + hex_to_u8(a[1])).collect()\n}\n\nfn vec_xor(v1: &Vec<u8>, v2: &Vec<u8>) -> Vec<u8> {\n    let mut v = Vec::with_capacity(cmp::min(v1.len(), v2.len()));\n\n    for (a, b) in v1.iter().zip(v2.iter()) {\n        v.push(a ^ b);\n    }\n\n    v\n}\n\nfn target_func() {\n    let input_file = File::open(\"in.txt\").unwrap();\n    let input = BufReader::new(input_file);\n    let input: Vec<_> = input.lines().filter_map(|res| res.ok()).take(11).map(|s| vec_u8_from_hex_string(&s)).collect();\n    let mut key: Vec<u8> = vec![0; 200];\n    let mut ws: Vec<u8> = vec![0; 200];\n\n    for i in 0..11 {\n        let c_i = &input[i];\n        println!(\"c_{}:\", i);\n        let c_xor: Vec<_> = input.iter().map(|v| to_ascii(&vec_xor(c_i, &v))).collect();\n\n        for x_j in c_xor.iter() {\n            println!(\"{}\", x_j);\n        }\n\n        for k in 0..c_i.len() {\n            let mut w = 0;\n\n            for x_j in c_xor.iter() {\n                if k < x_j.len() && is_alpha(x_j.as_bytes()[k]) {\n                    w += 1;\n                }\n            }\n\n            if w > ws[k] {\n                key[k] = c_i[k] ^ b' ';\n                ws[k] = w;\n            }\n        }\n\n        println!(\"key: {:?}\\n\", key);\n    }\n\n    for i in 0..11 {\n        println!(\"msg {}:\\t{}\\n\", i, to_ascii(&vec_xor(&input[i], &key)));\n    }\n}\n\nfn main(){\n    target_func();\n}\n\n", "entry_point": "target_func"}
{"task_id": "rust_2", "code": "\nfn merge<T: Copy + PartialOrd>(x1: &[T], x2: &[T], y: &mut [T]) {\n    assert_eq!(x1.len() + x2.len(), y.len());\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < x1.len() && j < x2.len() {\n        if x1[i] < x2[j] {\n            y[k] = x1[i];\n            k += 1;\n            i += 1;\n        } else {\n            y[k] = x2[j];\n            k += 1;\n            j += 1;\n        }\n    }\n    if i < x1.len() {\n        y[k..].copy_from_slice(&x1[i..]);\n    }\n    if j < x2.len() {\n        y[k..].copy_from_slice(&x2[j..]);\n    }\n}\n\nfn merge_sort<T: Copy + Ord>(x: &mut [T]) {\n\tlet n = x.len();\n\tlet m = n / 2;\n \n\tif n <= 1 {\n\t\treturn;\n\t}\n \n\tmerge_sort(&mut x[0..m]);\n\tmerge_sort(&mut x[m..n]);\n \n\tlet mut y: Vec<T> = x.to_vec();\n \n\tmerge(&x[0..m], &x[m..n], &mut y[..]);\n \n\tx.copy_from_slice(&y);\n}\n\nfn main() {\n    println!(\"Sort numbers ascending\");\n    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    merge_sort(&mut numbers);\n    println!(\"After:  {:?}\\n\", numbers);\n\n    println!(\"Sort strings alphabetically\");\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n    merge_sort(&mut strings);\n    println!(\"After:  {:?}\\n\", strings);\n}\n", "entry_point": "merge"}
{"task_id": "rust_3", "code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::path::Path;\n\nfn main() {\n    let input = read_input(Path::new(\"input.txt\"));\n\n    part1(&input);\n    part2(&input);\n}\n\nfn read_input(path: &Path) -> Vec<String> {\n    BufReader::new(File::open(path).unwrap())\n        .lines()\n        .map(|line_res| line_res.unwrap())\n        .collect()\n}\n\nfn part1(labels: &[String]) {\n    let mut labels_with_two = 0;\n    let mut labels_with_three = 0;\n\n    for label in labels {\n        let mut letters = HashMap::new();\n\n        for letter in label.as_bytes() {\n            let letter_cnt = letters.entry(letter).or_insert(0);\n            *letter_cnt += 1;\n        }\n\n        \n        if letters.values().any(|&cnt| cnt == 2) {\n            labels_with_two += 1;\n        }\n\n        \n        if letters.values().any(|&cnt| cnt == 3) {\n            labels_with_three += 1;\n        }\n    }\n\n    println!(\n        \"Part 1: Checksum: {} (6474)\",\n        labels_with_two * labels_with_three\n    );\n}\n\nfn part2(labels: &[String]) {\n    for (i, label_a) in labels.iter().enumerate() {\n        for label_b in labels.iter().skip(i + 1) {\n            if labels_similar(label_a, label_b) {\n                println!(\n                    \"Part 2: Same Letters: {} (mxhwoglxgeauywfkztndcvjqr)\",\n                    same_letters(label_a, label_b)\n                );\n                return;\n            }\n        }\n    }\n}\n\nfn labels_similar(a: &str, b: &str) -> bool {\n    a.as_bytes().iter().zip(b.as_bytes()).fold(\n        0,\n        |acc, pair| {\n            if *pair.0 != *pair.1 {\n                acc + 1\n            } else {\n                acc\n            }\n        },\n    ) == 1\n}\n\nfn same_letters(a: &str, b: &str) -> String {\n    let same_bytes = a\n        .as_bytes()\n        .iter()\n        .zip(b.as_bytes())\n        .filter_map(|pair| {\n            if *pair.0 == *pair.1 {\n                Some(*pair.0)\n            } else {\n                None\n            }\n        })\n        .collect();\n\n    String::from_utf8(same_bytes).unwrap()\n}\n", "entry_point": "part1"}
{"task_id": "rust_4", "code": "use std::env;\nuse std::fs::File;\nuse std::io::{self, BufRead};\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let filename = &args[1];\n    let file = File::open(filename).unwrap();\n    let lines: Vec<String> = io::BufReader::new(file)\n        .lines()\n        .map(|line| line.unwrap())\n        .collect();\n    let pairs: Vec<(i64, i64)> = lines[1]\n        .split(\",\")\n        .enumerate()\n        .filter(|&(_, id)| id != \"x\")\n        .map(|(idx, id)| (idx as i64, id.parse::<i64>().unwrap()))\n        .collect();\n    print!(\"{}\", garners_algorithm(pairs));\n}\n\nfn garners_algorithm(pairs: Vec<(i64, i64)>) -> i64 {\n    let k = pairs.len();\n    let mut x = vec![0; k];\n    for i in 0..k {\n        x[i] = pairs[i].1 - pairs[i].0;\n        for j in 0..i {\n            x[i] = mod_inv(pairs[j].1, pairs[i].1) * (x[i] - x[j]);\n            x[i] = x[i] % pairs[i].1;\n            if x[i] < 0 {\n                x[i] += pairs[i].1;\n            }\n        }\n    }\n\n    let mut ts = 0i64;\n    for i in 0..k {\n        let mut product = x[i];\n        for j in 0..i {\n            product *= pairs[j].1;\n        }\n        ts += product;\n    }\n\n    return ts;\n}\n\n\nfn mod_inv(a: i64, module: i64) -> i64 {\n    let mut mn = (module, a);\n    let mut xy = (0, 1);\n    while mn.1 != 0 {\n        xy = (xy.1, xy.0 - (mn.0 / mn.1) * xy.1);\n        mn = (mn.1, mn.0 % mn.1);\n    }\n    while xy.0 < 0 {\n        xy.0 += module;\n    }\n    xy.0\n}\n", "entry_point": "garners_algorithm"}
{"task_id": "rust_5", "code": "use std::mem::{self, ManuallyDrop};\nuse std::ptr;\n\n\nfn quick_sort<T>(vec: &mut [T], lo: usize, hi: usize) \n\twhere T: PartialOrd,\n{\n\tif hi == lo {\n\t\treturn;\n\t}\n\tlet (sp_idx0, sp_idx1) = partition(vec, lo, hi);\n\tif sp_idx0 != lo {\n\t\tquick_sort(vec, lo, sp_idx0 - 1);\n\t}\n\tif sp_idx1 != hi {\n\t\tquick_sort(vec, sp_idx1 + 1, hi);\n\t}\n}\n\n\nfn partition<T>(vec: &mut [T], lo: usize, hi: usize) -> (usize, usize)\n\twhere T: PartialOrd,\n{\n\tlet mut lt = lo;\n\tlet mut gt = hi;\n\tlet mut i = lo + 1;\n\tlet v = ManuallyDrop::new(unsafe {ptr::read(&vec[lo])});\n\twhile i <= gt {\n\t\tif vec[i] < *v {\n\t\t\tswap(vec, i, lt);\n\t\t\ti += 1;\n\t\t\tlt += 1;\n\t\t}else if vec[i] > *v {\n\t\t\tswap(vec, i, gt);\n\t\t\tgt -= 1;\n\t\t}else {\n\t\t\ti += 1;\n\t\t}\n\t}\n\t(lt, gt)\n}\n\nfn swap<T>(vec: &mut [T], idx1: usize, idx2: usize)\n\twhere T: PartialOrd,\n{\n\tif idx1 == idx2 {\n\t\treturn;\n\t}\n\tlet mut tmp = unsafe { ptr::read(&mut vec[idx1]) };\n\tmem::swap(&mut tmp, &mut vec[idx2]);\n    unsafe {\n        ptr::write(&mut vec[idx1] as *mut _, tmp);\n    }\n\n}\n\nfn main() {\n\tlet mut vec = vec![10, 4, 20, 11, 5, 6, 22, 50, 43, 25, 33, 13, 26, 27, 43, 47, 48];\n\tlet len = vec.len();\n\tquick_sort(&mut vec[..], 0, len - 1);\n\tprintln!(\"{:?}\", vec);\n\tprintln!(\"hello night!\");\n}\n", "entry_point": "partition"}
{"task_id": "rust_6", "code": "\nfn cocktail_shaker_sort<T: PartialOrd>(a: &mut [T]) {\n    let mut begin = 0;\n    let mut end = a.len();\n    if end == 0 {\n        return;\n    }\n    end -= 1;\n    while begin < end {\n        let mut new_begin = end;\n        let mut new_end = begin;\n        for i in begin..end {\n            if a[i + 1] < a[i] {\n                a.swap(i, i + 1);\n                new_end = i;\n            }\n        }\n        end = new_end;\n        let mut i = end;\n        while i > begin {\n            if a[i] < a[i - 1] {\n                a.swap(i, i - 1);\n                new_begin = i;\n            }\n            i -= 1;\n        }\n        begin = new_begin;\n    }\n}\n \nfn main() {\n    let mut v = vec![5, 1, -6, 12, 3, 13, 2, 4, 0, 15];\n    println!(\"before: {:?}\", v);\n    cocktail_shaker_sort(&mut v);\n    println!(\"after:  {:?}\", v);\n}", "entry_point": "cocktail_shaker_sort"}
{"task_id": "rust_7", "code": "use std::fs;\nuse std::collections::{HashMap,HashSet};\n\n\nfn reverse_rules_dfs(reverse_rules: &HashMap<String,HashSet<String>>, start: &str) -> HashSet<String> {\n    let mut nodes: HashSet<String> = HashSet::new();\n    nodes.insert(start.to_owned());\n    if let Some(set) = reverse_rules.get(start) {\n        for parent in set {\n            nodes.extend(reverse_rules_dfs(reverse_rules, parent));\n        }\n    }\n    return nodes;\n}\n\n\nfn rules_counting_dfs(rules: &HashMap<String,HashMap<String,usize>>, start: &str) -> usize {\n    let mut sum = 1usize;\n    if let Some(set) = rules.get(start) {\n        for (child,count) in set {\n            sum += count * rules_counting_dfs(rules, child);\n        }\n    }\n    return sum;\n}\n\nfn target_func() {\n    let file = fs::read_to_string(\"input.txt\").expect(\"File does not exist\");\n\n    \n    let mut rules: HashMap<String, HashMap<String,usize>> = HashMap::new();\n\n    \n    let mut reverse_rules: HashMap<String,HashSet<String>> = HashMap::new();\n\n    for line in file.lines() {\n        let (container,tail) = line.split_at(line.find(\" bags contain \").unwrap());\n        rules.insert(container.to_owned(),HashMap::new());\n        let mut remaining = tail.split_at(14).1;\n        loop {\n            let (num_str,bag_and_tail) = remaining.split_at(remaining.find(\" \").unwrap());\n            if num_str == \"no\" {\n                break;\n            } else {\n                let num: usize = num_str.parse().unwrap();\n                let corrected_bag_and_tail = bag_and_tail.split_at(1).1;\n                let (bag,tail_yet_again) = corrected_bag_and_tail.split_at(corrected_bag_and_tail.find(\" bag\").unwrap());\n                rules.get_mut(container).unwrap().insert(bag.to_owned(),num);\n                if !reverse_rules.contains_key(bag) {\n                    reverse_rules.insert(bag.to_owned(), HashSet::new());\n                }\n                reverse_rules.get_mut(bag).unwrap().insert(container.to_owned());\n                if tail_yet_again.starts_with(\" bags.\") || tail_yet_again.starts_with(\" bag.\") {\n                    break;\n                }\n                remaining = tail_yet_again.split_at(tail_yet_again.find(\", \").unwrap() + 2).1;\n            }\n        }\n    }\n    let shiny_gold_containing_ways = reverse_rules_dfs(&reverse_rules, \"shiny gold\").len() - 1;\n    println!(\"There are {} ways for the shiny gold bag to be contained.\", shiny_gold_containing_ways);\n\n    let shiny_gold_contained = rules_counting_dfs(&rules, \"shiny gold\") - 1;\n    println!(\"There are {} bags contained in the shiny gold bag.\", shiny_gold_contained);\n}\n\nfn main(){\n    target_func();\n}\n", "entry_point": "target_func"}
{"task_id": "rust_8", "code": "use std::collections::HashSet;\nuse std::fs;\n\nfn main() {\n    let input = fs::read_to_string(\"input/day24\").expect(\"failure opening input file\");\n    let blacks = p1(&input);\n    println!(\"Part1: {}\", blacks.len());\n    println!(\"Part2: {}\", p2(blacks));\n}\n\nfn p1(input: &str) -> HashSet<(i32, i32)> {\n    input\n        .lines()\n        .map(|line| identify_tile(&line))\n        .fold(HashSet::new(), |mut blacks, tile| {\n            if blacks.contains(&tile) {\n                blacks.remove(&tile);\n            } else {\n                blacks.insert(tile);\n            }\n            blacks\n        })\n}\n\nfn p2(mut blacks: HashSet<(i32, i32)>) -> usize {\n    let mut whites = (-100..100)\n        .map(|x| (-100..100).map(|y| (x, y)).collect::<Vec<(i32, i32)>>())\n        .flatten()\n        .filter(|p| !blacks.contains(p))\n        .fold(HashSet::new(), |mut whites, p| {\n            whites.insert(p);\n            whites\n        });\n\n    let deltas = [(0, -1), (1, -1), (1, 0), (0, 1), (-1, 1), (-1, 0)];\n    (0..100).for_each(|_| {\n        let mut next_blacks = HashSet::new();\n        let mut next_whites = HashSet::new();\n        for b in &blacks {\n            let neighbors = deltas\n                .iter()\n                .map(|d| (b.0 + d.0, b.1 + d.1))\n                .filter(|n| blacks.contains(n))\n                .count();\n            if neighbors == 0 || neighbors > 2 {\n                next_whites.insert(*b);\n            } else {\n                next_blacks.insert(*b);\n            }\n        }\n        for w in &whites {\n            let neighbors = deltas\n                .iter()\n                .map(|d| (w.0 + d.0, w.1 + d.1))\n                .filter(|n| blacks.contains(n))\n                .count();\n            if neighbors == 2 {\n                next_blacks.insert(*w);\n            } else {\n                next_whites.insert(*w);\n            }\n        }\n        blacks = next_blacks;\n        whites = next_whites;\n    });\n    blacks.len()\n}\n\nfn identify_tile(moves: &str) -> (i32, i32) {\n    let mut i = 0;\n    let mut coords = (0, 0);\n    while i < moves.len() {\n        match moves.get(i..i + 2) {\n            Some(\"nw\") => {\n                coords.1 -= 1;\n                i += 2\n            }\n            Some(\"ne\") => {\n                coords.0 += 1;\n                coords.1 -= 1;\n                i += 2\n            }\n            Some(\"sw\") => {\n                coords.0 -= 1;\n                coords.1 += 1;\n                i += 2\n            }\n            Some(\"se\") => {\n                coords.1 += 1;\n                i += 2\n            }\n            _ => match moves.get(i..i + 1) {\n                Some(\"w\") => {\n                    coords.0 -= 1;\n                    i += 1\n                }\n                Some(\"e\") => {\n                    coords.0 += 1;\n                    i += 1\n                }\n                _ => unreachable!(\"unrecognized direction\"),\n            },\n        }\n    }\n    coords\n}\n", "entry_point": "p2"}
{"task_id": "rust_9", "code": "use std::fmt::Debug;\n\nconst MIN_X: i32 = 85;\nconst MAX_X: i32 = 145;\n\nconst MIN_Y: i32 = -163;\nconst MAX_Y: i32 = -108;\n\n#[derive(Debug, Copy, Clone)]\nstruct Possible {\n    value: i32,\n    min_t: i32,\n    max_t: i32\n}\n\nimpl Default for Possible {\n    fn default() -> Possible { \n        Possible { \n            value: 0,\n            min_t: 0,\n            max_t: i32::MAX,\n        }\n    }\n}\n\nfn target_func() {\n    \n    let mut possible_xs = vec!();\n\n    for x in 1..MAX_X {\n        let mut min_t = 0;\n        let mut max_t = 0;\n        let mut found = false;\n\n        let mut possible = Possible::default();\n\n        for t in 0..=x {\n            let distance = t * x - t * (t - 1)/2;\n            \n            if distance >= MIN_X && distance <= MAX_X {\n                if !found {\n                    min_t = t;\n                    max_t = t;\n                    found = true;\n                }\n                else {\n                    max_t = t;\n                }\n            }\n\n            if distance >= MIN_X && distance <= MAX_X && t == x {\n                println!(\"Possible: x: {}, min_t: {}, max_t: {}\", x, min_t, max_t);\n                max_t = i32::MAX;\n            }\n\n            if found {\n                \n                possible = Possible {value: x, min_t: min_t, max_t: max_t};\n            }\n        }\n\n        if found {\n            possible_xs.push(possible);\n        }\n    }\n    \n    println!(\"{:?}\", possible_xs);\n\n    let mut possible_ys = vec!();\n\n    for y in 0..-MIN_Y {\n        println!(\"Y: {}\", y);\n        for t in 1..i32::MAX {\n            let distance = y * t - (t * (t - 1)) / 2;\n            if distance >= MIN_Y && distance <= MAX_Y {\n                println!(\"Possible: y: {}, t: {}\", y, t);\n                let possible = Possible{value: y, min_t: t, max_t: t};\n                possible_ys.push(possible);\n            }\n\n            if distance < MIN_Y {\n                break;\n            }\n        }\n    }\n}\n\nfn main(){\n    target_func();\n}\n", "entry_point": "target_func"}
{"task_id": "rust_10", "code": "\nuse std::fs;\nuse std::string::String;\n\nfn main() {\n    let filename = format!(\"inputs/{}.txt\", module_path!());\n    let text = fs::read(filename).ok().expect(\"Couldn't open file\");\n    let str = String::from_utf8(text).ok().expect(\"Could parse UTF8 from file\");\n\n    println!(\"{}\", first_part(&str));\n    println!(\"{}\", second_part(&str));\n}\n\nenum ParseResult {\n    Corrupt(char),\n    Incomplete(String),\n    Complete,\n}\n\nfn parse(line: &str) -> ParseResult {\n    let mut stack = Vec::new();\n    for c in line.chars() {\n        match c {\n            '(' => stack.push(')'),\n            '[' => stack.push(']'),\n            '{' => stack.push('}'),\n            '<' => stack.push('>'),\n            _ => match stack.pop() {\n                Some(d) => if c != d {\n                    return ParseResult::Corrupt(c)\n                },\n                None => return ParseResult::Corrupt(c)\n            },\n        }\n    }\n\n    if stack.len() == 0 {\n        ParseResult::Complete\n    } else {\n        ParseResult::Incomplete(stack.iter().rev().collect())\n    }\n}\n\nfn first_part(s: &str) -> usize {\n    let mut result = 0;\n    for l in s.split_whitespace() {\n        match parse(l) {\n            ParseResult::Corrupt(c) => match c {\n                ')' => result += 3,\n                ']' => result += 57,\n                '}' => result += 1197,\n                '>' => result += 25137,\n                _ => unreachable!(),\n            },\n            _ => {},\n        }\n    }\n    result\n}\n\nfn second_part(s: &str) -> usize {\n    let mut scores = Vec::new();\n    for l in s.split_whitespace() {\n        let mut score = 0;\n        match parse(l) {\n            ParseResult::Incomplete(stack) => {\n                for c in stack.chars() {\n                    score *= 5;\n                    match c {\n                        ')' => score += 1,\n                        ']' => score += 2,\n                        '}' => score += 3,\n                        '>' => score += 4,\n                        _ => unreachable!(),\n                    }\n                }\n                scores.push(score);\n            },\n            _ => {},\n        }\n    }\n    scores.sort_unstable();\n    scores[scores.len()/2]\n}\n", "entry_point": "second_part"}
{"task_id": "rust_11", "code": "fn main() {\n    assert_eq!(Solution::num_decodings(String::from(\"*\")), 9);\n}\n\nstruct Solution {}\n\nimpl Solution {\n    \n    pub fn num_decodings(s: String) -> i32 {\n        let modu: usize = 10usize.pow(9) + 7;\n        let s: Vec<u8> = s.bytes().map(|x| if x == b'*' { x } else { x - b'0' }).collect();\n        let length = s.len() + 1;\n        let mut dp = vec![(0, 0); length];\n        dp[length - 1].0 = 1;\n        dp[length - 2].0 = match s[length - 2] {\n            b'*' => 9,\n            0 => 0,\n            _ => 1,\n        };\n        for i in (0..length-2).rev() {\n            match s[i] {\n                0 => {\n                    dp[i].0 = 0;\n                    dp[i].1 = 0;\n                }\n                b'*' => {\n                    dp[i].0 = 9 * (dp[i+1].0 + dp[i+1].1);\n                    dp[i].1 = if s[i+1] == b'*' { 15 } else {\n                        if s[i+1] <= 6 { 2 } else { 1 }\n                    } * (dp[i+2].0 + dp[i+2].1);\n                }\n                x => {\n                    dp[i].0 = dp[i+1].0 + dp[i+1].1;\n                    dp[i].1 = if s[i+1] == b'*' {\n                        if x == 1 { 9 }\n                        else if x == 2 { 6 }\n                        else { 0 }\n                    } else {\n                        if s[i] * 10 + s[i+1] <= 26 { 1 } else { 0 }\n                    } * (dp[i+2].0 + dp[i+2].1);\n                }\n            }\n            dp[i].0 %= modu;\n            dp[i].1 %= modu;\n        }\n        println!(\"modu = {:#?}\", modu);\n        println!(\"s = {:#?}, dp = {:#?}\", s, dp);\n        ((dp[0].0 + dp[0].1) % modu) as i32\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::*;\n\n    #[test]\n    fn basic() {\n        assert_eq!(Solution::num_decodings(String::from(\"*\")), 9);\n        assert_eq!(Solution::num_decodings(String::from(\"1*\")), 18);\n    }\n\n    #[test]\n    fn fail() {\n        assert_eq!(Solution::num_decodings(String::from(\"**\")), 96);\n        assert_eq!(Solution::num_decodings(String::from(\"**********1111111111\")), 133236775);\n    }\n}", "entry_point": "num_decodings"}
{"task_id": "rust_12", "code": "use std::env;\nuse std::error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::str::Split;\n\ntype Result<T> = std::result::Result<T, Box<error::Error>>;\n\nfn main() -> Result<()> {\n    let args: Vec<String> = env::args().collect();\n\n    let filename = &args[1];\n\n    let contents = get_contents(filename)?;\n    let mut split = contents.split(\" \");\n\n    let tree: TreeGraph = parse_node(&mut split)?;\n\n    println!(\"{}\", metadata_total(&tree));\n    println!(\"{}\", value(&tree));\n\n    Ok(())\n}\n\n#[derive(Debug)]\nstruct TreeGraph {\n    children: Vec<TreeGraph>,\n    metadata: Vec<usize>,\n}\n\nfn metadata_total(tree: &TreeGraph) -> usize {\n    let mut res: usize = 0;\n\n    for m in (*tree).metadata.iter() {\n        res += m;\n    }\n\n    for child in (*tree).children.iter() {\n        res += metadata_total(&*child);\n    }\n\n    res\n}\n\nfn value(tree: &TreeGraph) -> usize {\n    let nchildren = tree.children.len();\n    let mut res: usize = 0;\n    if nchildren == 0 {\n        res = tree.metadata.iter().sum();\n    } else {\n        for m in tree.metadata.iter() {\n            if *m - 1 >= nchildren {\n                continue;\n            }\n            let children: &[TreeGraph] = &tree.children;\n            let child: &TreeGraph = children.iter().nth(*m - 1).unwrap();\n            let unboxed_child: &TreeGraph = &*child;\n            res += value(unboxed_child);\n        }\n    }\n    res\n}\n\nfn parse_node(s: &mut Split<&str>) -> Result<TreeGraph> {\n    let mut children_fromstr: Vec<TreeGraph> = Vec::new();\n    let mut metadata_fromstr: Vec<usize> = Vec::new();\n\n    let nchildren = match s.next() {\n        Some(x) => x.to_string().parse::<usize>()?,\n        None => 0,\n    };\n\n    let nmetadata = match s.next() {\n        Some(x) => x.to_string().parse::<usize>()?,\n        None => 0,\n    };\n\n    for _ in 0..nchildren {\n        let g: TreeGraph = parse_node(s)?;\n        children_fromstr.push(g);\n    }\n\n    for _ in 0..nmetadata {\n        metadata_fromstr.push(s.next().unwrap().to_string().parse::<usize>()?);\n    }\n\n    Ok(TreeGraph {\n        children: children_fromstr,\n        metadata: metadata_fromstr,\n    })\n}\n\nfn get_contents(filename: &str) -> Result<String> {\n    let mut f = File::open(filename)?;\n\n    let mut contents = String::new();\n    f.read_to_string(&mut contents)?;\n\n    Ok(contents)\n}\n", "entry_point": "value"}
{"task_id": "rust_13", "code": "use std::io::BufRead;\nuse std::io::BufReader;\nuse std::fs::File;\nuse std::collections::HashSet;\n\nfn target_func() {\n    let f = File::open(\"input.txt\").unwrap();\n\n    let mut bugs : [[[bool; 5]; 5]; 2] = [[[false; 5];5];2];\n    let mut current : usize = 0;\n    let mut next : usize = 1;\n\n    let mut col: i32 = 0;\n    for raw_line in BufReader::new(f).lines() {\n        for (row, c) in raw_line.unwrap().chars().enumerate() {\n            if c == '#' {\n                bugs[current][col as usize][row as usize] = true;\n            } \n        }\n        col += 1;\n    }\n\n    let mut sb : HashSet<u64> = HashSet::new();\n\n    let deltas : [(i32, i32); 4] = [(0,1), (0,-1), (1,0), (-1,0)];\n    loop {\n        for i in 0..5usize {\n            for j in 0..5usize {\n                bugs[next][i][j] = false;\n            }\n        }\n\n        for i in 0..5usize {\n            for j in 0..5usize {\n                let mut count : i32 = 0;\n\n                for delta in deltas.iter() {\n                    let ii : i32 = i as i32 + delta.0;\n                    let jj : i32 = j as i32 + delta.1;\n\n                    if ii < 0 || jj < 0 || ii > 4 || jj > 4 {\n                        continue;\n                    }\n\n                    if bugs[current][ii as usize][jj as usize] {\n                        count += 1;\n                    }\n                }\n\n                if bugs[current][i][j] {\n                    if count == 1 {\n                        bugs[next][i][j] = true;\n                    }\n                } else {\n                    if count == 1 || count == 2 {\n                        bugs[next][i][j] = true;\n                    }\n                }\n           }\n        }\n        let mut sum : u64 = 0;\n        let mut p : u64 = 1;\n        for i in 0..5usize {\n            for j in 0..5usize {\n               if bugs[next][i as usize][j as usize] {\n                   sum += p;\n               }\n               p = p << 1;\n           }\n        }\n        if sb.contains(&sum) {\n            println!(\"{}\", sum);\n            return;\n        }\n        sb.insert(sum);\n\n        if current == 0 {\n            current = 1;\n            next = 0;\n        } else {\n            current = 0;\n            next = 1;\n        }\n\n    }\n}\n\nfn main(){\n    target_func();\n}\n", "entry_point": "target_func"}
{"task_id": "rust_14", "code": "fn print_recipes(scores: &Vec<u8>, first: &usize, second: &usize) {\n    for (idx, i) in scores.iter().enumerate() {\n        match idx {\n            _ if &idx == first => print!(\"({})\", i),\n            _ if &idx == second => print!(\"[{}]\", i),\n            _ => print!(\" {} \", i),\n        }\n    }\n    println!();\n}\n\nfn next_ten_recipe_scores(recipe_count: usize) -> Vec<u8> {\n    let mut recipe_scores: Vec<u8> = vec![3, 7];\n    let mut first_elf_recipe_idx = 0;\n    let mut second_elf_recipe_idx = 1;\n\n    while recipe_scores.len() < (recipe_count + 10) {\n        let first_recipe = recipe_scores[first_elf_recipe_idx];\n        let second_recipe = recipe_scores[second_elf_recipe_idx];\n        let new_recipes = first_recipe + second_recipe;\n        if new_recipes >= 10 {\n            recipe_scores.push(1);\n        }\n        recipe_scores.push(new_recipes % 10);\n        first_elf_recipe_idx += first_recipe as usize + 1;\n        first_elf_recipe_idx = first_elf_recipe_idx % recipe_scores.len();\n        second_elf_recipe_idx += second_recipe as usize + 1;\n        second_elf_recipe_idx = second_elf_recipe_idx % recipe_scores.len();\n    }\n    recipe_scores[recipe_count..recipe_count + 10].to_vec()\n}\n\nfn last_matching(seq: &[u8], last: &[u8]) -> usize {\n    let mut matching = last.len();\n    while matching > 0 {\n        let idx = if matching > seq.len() {\n            0\n        } else {\n            seq.len() - matching\n        };\n        let a = &seq[idx..];\n        let b = &last[0..matching];\n        if a == b {\n            return matching;\n        }\n        matching -= 1;\n    }\n    matching\n}\n\n\n\nfn find_recipes_before_sequence(recipe_seq: &Vec<u8>) -> usize {\n    let mut recipe_scores: Vec<u8> = vec![3, 7];\n    let mut first_elf_recipe_idx = 0;\n    let mut second_elf_recipe_idx = 1;\n\n    let mut num_recipes: usize = 2;\n    let mut num_recipes_matching = last_matching(&recipe_scores, &recipe_seq);\n    loop {\n        let first_recipe = recipe_scores[first_elf_recipe_idx];\n        let second_recipe = recipe_scores[second_elf_recipe_idx];\n        let new_recipes = first_recipe + second_recipe;\n        if new_recipes >= 10 {\n            num_recipes += 1;\n            recipe_scores.push(1);\n            if recipe_seq[num_recipes_matching] == 1 {\n                num_recipes_matching += 1;\n                if num_recipes_matching == recipe_seq.len() {\n                    return num_recipes - num_recipes_matching;\n                }\n            } else if num_recipes_matching > 0 {\n                num_recipes_matching = last_matching(&recipe_scores, &recipe_seq);\n            }\n        }\n        let added = new_recipes % 10;\n        num_recipes += 1;\n        recipe_scores.push(added);\n        if recipe_seq[num_recipes_matching] == added {\n            num_recipes_matching += 1;\n            if num_recipes_matching == recipe_seq.len() {\n                return num_recipes - num_recipes_matching;\n            }\n        } else if num_recipes_matching > 0 {\n            num_recipes_matching = last_matching(&recipe_scores, &recipe_seq);\n        }\n\n        first_elf_recipe_idx += first_recipe as usize + 1;\n        first_elf_recipe_idx = first_elf_recipe_idx % recipe_scores.len();\n        second_elf_recipe_idx += second_recipe as usize + 1;\n        second_elf_recipe_idx = second_elf_recipe_idx % recipe_scores.len();\n    }\n}\n\nfn main() {\n    let input = 846021;\n    let input_seq = vec![8, 4, 6, 0, 2, 1];\n    println!(\n        \"The next ten recipe scores after recipe {} are {:?}\",\n        input,\n        next_ten_recipe_scores(input)\n    );\n    println!(\n        \"There are {} recipes before the sequence {:?}\",\n        find_recipes_before_sequence(&input_seq),\n        &input_seq\n    );\n}\n", "entry_point": "find_recipes_before_sequence"}
{"task_id": "rust_15", "code": "use std::io::{self, BufRead};\nuse std::collections::HashMap;\n\nconst PREF_LENGTH: usize = 2;\nconst SUFF_LENGTH: usize = 2;\nconst PAD_LENGTH: i64 = PREF_LENGTH as i64 + SUFF_LENGTH as i64 + 1;\nconst POT_PLANT: char = '#';\nconst POT_EMPTY: char = '.';\n\n#[derive(Debug)]\nstruct Rule {\n    pattern: Vec<char>,\n    outcome: char,\n}\nimpl Rule {\n    pub fn new(pattern: &str, outcome: &str) -> Rule {\n        Rule{ pattern: pattern.to_string().chars().collect(), outcome: outcome.to_string().chars().next().unwrap() }\n    }\n}\n\n#[derive(Debug)]\nstruct Data {\n    initial: String,\n    rules: Vec<Rule>,\n}\nimpl Data {\n    pub fn new() -> Data {\n        Data{ initial: \"\".to_string(), rules: Vec::new() }\n    }\n    pub fn set_initial(&mut self, initial: &str) {\n        self.initial = initial.to_string();\n    }\n    pub fn add_rule(&mut self, pattern: &str, outcome: &str) {\n        self.rules.push(Rule::new(pattern, outcome));\n    }\n}\n\n#[derive(Debug)]\nstruct Soil {\n    iterations: usize,\n    data: [Vec<char>; 2],\n    cur: usize,\n    beg: usize,\n    end: usize,\n    off: i64,\n    seen: HashMap<String, (usize, i64)>,\n}\nimpl Soil {\n    fn set_pos(&mut self, which: usize, pos: usize, val: char) {\n        if pos < self.data[which].len() {\n            self.data[which][pos] = val;\n        } else {\n            self.data[which].push(val);\n        }\n    }\n    pub fn new(initial: &str, iterations: usize) -> Soil {\n        let data0 = Vec::new();\n        let data1 = Vec::new();\n        let seen = HashMap::new();\n        let cur = 0;\n        let mut soil = Soil{ data: [ data0, data1 ], cur, off: 0, beg: 0, end: 0, seen, iterations };\n\n        let mut first = true;\n        let mut pos = 0;\n        for _p in 0..PAD_LENGTH {\n            soil.set_pos(cur, pos, POT_EMPTY);\n            pos += 1;\n        }\n        for _c in initial.chars() {\n            let outcome = if _c == POT_EMPTY { POT_EMPTY } else { POT_PLANT };\n            if outcome != POT_EMPTY  {\n                if first {\n                    soil.beg = pos;\n                    first = false;\n                }\n                soil.end = pos + 1;\n            }\n            if !first || outcome != POT_EMPTY {\n                soil.set_pos(cur, pos, outcome);\n                pos += 1;\n            }\n        }\n        for _p in 0..PAD_LENGTH {\n            soil.set_pos(cur, pos, POT_EMPTY);\n            pos += 1;\n        }\n        soil\n    }\n    \n    pub fn step(&mut self, rules: &Vec<Rule>) {\n        let nxt = 1 - self.cur;\n        let mut first = true;\n        let mut pos = 0;\n        for _p in 0..PAD_LENGTH {\n            self.set_pos(nxt, pos, POT_EMPTY);\n            pos += 1;\n        }\n        for _p in (self.beg-PREF_LENGTH)..(self.end+SUFF_LENGTH) {\n            let mut outcome = POT_EMPTY;\n            for rule in rules {\n                let mut matched = true;\n                for _j in 0..rule.pattern.len() {\n                    if rule.pattern[_j] != self.data[self.cur][_p+_j-PREF_LENGTH] {\n                        matched = false;\n                        break;\n                    }\n                }\n                if matched {\n                    outcome = rule.outcome;\n                    break;\n                }\n            }\n            if outcome != POT_EMPTY  {\n                if first {\n                    self.beg = pos;\n                    self.off += _p as i64 - self.beg as i64;\n                    first = false;\n                }\n                self.end = pos + 1;\n            }\n            if !first || outcome != POT_EMPTY {\n                self.set_pos(nxt, pos, outcome);\n                pos += 1;\n            }\n        }\n        for _p in 0..PAD_LENGTH {\n            self.set_pos(nxt, pos, POT_EMPTY);\n            pos += 1;\n        }\n        self.cur = nxt;\n    }\n    pub fn done(&mut self, iter: usize) -> bool {\n        let current: String = self.data[self.cur].iter().collect();\n        match self.seen.get(&current) {\n            Some(&(i, o)) => {\n                let delta_iter = iter - i;\n                let delta_off = self.off - o;\n                println!(\"{}: SEEN iter {} off {} => {} {}\", iter, i, o, delta_iter, delta_off);\n                let remaining = self.iterations - iter;\n                let final_offset: i64 = o as i64 + remaining as i64 * delta_off as i64;\n                println!(\"REMAINING {} => {}\", remaining, final_offset);\n                self.off = final_offset;\n                true\n            },\n            _ => {\n                self.seen.insert(current, (iter, self.off));\n                false\n            },\n        }\n    }\n}\n\nfn main() {\n    let data = read_data();\n    run(&data, 20);\n    run(&data, 50_000_000_000);\n}\n\n\n\n\n\n\nfn run(data: &Data, iterations: usize) {\n    let mut soil = Soil::new(&data.initial, iterations);\n\n    for iter in 0..iterations {\n        soil.step(&data.rules);\n        if soil.done(iter) {\n            break;\n        }\n    }\n\n    let mut total: i64 = 0;\n    for pos in 0..soil.data[soil.cur].len() {\n        if soil.data[soil.cur][pos] == POT_EMPTY {\n            continue;\n        }\n        total += pos as i64 + soil.off - PAD_LENGTH;\n    }\n    println!(\"Sum of pots with plants after {} generations: {}\", iterations, total);\n}\n\nfn read_data() -> Data {\n    let mut data = Data::new();\n    let stdin = io::stdin();\n    for line in stdin.lock().lines() {\n        let line = line.unwrap();\n        let words: Vec<&str> = line.split_whitespace().collect();\n        if words.len() < 3 {\n            continue;\n        }\n        if words[0] == \"initial\" {\n            data.set_initial(words[2]);\n            continue;\n        }\n        data.add_rule(words[0], words[2]);\n    }\n    data\n}\n", "entry_point": "step"}
{"task_id": "rust_16", "code": "use std::collections::HashMap;\n\nstruct Solution {}\n\nimpl Solution {\n    \n    pub fn check_inclusion(s1: String, s2: String) -> bool {\n        if s1.len() > s2.len() {\n            return false;\n        }\n        let mut s1_map = HashMap::new();\n        let mut s2_map = HashMap::new();\n        \n        for ch in s1.chars() {\n            let counter = s1_map.entry(ch).or_insert(0);\n            *counter += 1;\n        }\n        let s1_len = s1.len();\n        let mut total_distence = s1_len;\n        for (idx, ch) in s2.chars().enumerate() {\n            \n            if s1_map.contains_key(&ch) {\n                let counter = s2_map.entry(ch).or_insert(0);\n                *counter += 1;\n                if *counter <= s1_map[&ch] {\n                    total_distence -= 1;\n                } else {\n                    total_distence += 1;\n                }\n            }\n            \n            if idx < s1_len {\n                if total_distence == 0 {\n                    return true\n                }\n                continue;\n            }\n            let remove_ch = s2.chars().nth(idx-s1_len).unwrap();\n            if s2_map.contains_key(&remove_ch) {\n                if s2_map[&remove_ch] <= s1_map[&remove_ch] {\n                    total_distence += 1;\n                } else {\n                    total_distence -= 1;\n                }\n                *s2_map.get_mut(&remove_ch).unwrap() -= 1;\n                \n            }\n            \n            if total_distence == 0 {\n                return true\n            }\n        }\n        if total_distence == 0 {\n            return true\n        }\n        false\n    }\n}\n\nfn main() {\n    let s1 = String::from(\"a\");\n    let s2 = String::from(\"ab\");\n    println!(\"{}\", Solution::check_inclusion(s1, s2));\n}\n", "entry_point": "check_inclusion"}
{"task_id": "rust_17", "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_first_half() {\n        assert_eq!(run_simulation(5, false), 0124515891u64);\n        assert_eq!(run_simulation(9, false), 5158916779u64);\n        assert_eq!(run_simulation(18, false), 9251071085u64);\n        assert_eq!(run_simulation(2018, false), 5941429882u64);\n    }\n\n    #[test]\n    fn test_second_half() {\n        assert_eq!(run_simulation(515891, true), 9);\n        assert_eq!(run_simulation(012451, true), 5);\n        assert_eq!(run_simulation(925107, true), 18);\n        assert_eq!(run_simulation(594142, true), 2018);\n    }\n}\n\nfn check_recipes(recipes: &Vec<usize>, input: usize) -> u64 {\n    let end = recipes.len() - 1;\n    if end < 7 {\n        return 0;\n    }\n    if recipes[end] == input % 10 {\n        let mut sum = 0;\n        let mut coeff = 1;\n        for i in 0..6 {\n            sum += recipes[end - i] * coeff;\n            coeff *= 10;\n        }\n        if sum == input {\n            return end as u64 - 5;\n        }\n    }\n\n    if recipes[end - 1] == input % 10 {\n        let mut sum = 0;\n        let mut coeff = 1;\n        for i in 0..6 {\n            sum += recipes[end - 1 - i] * coeff;\n            coeff *= 10;\n        }\n        if sum == input {\n            return end as u64 - 6;\n        }\n\n    }\n\n    0\n}\n\n\nfn run_simulation(input: usize, find_occurrence: bool) -> u64 {\n    let mut recipes = vec![3, 7];\n    let mut elves = vec![0, 1];\n    loop {\n        let mut sum = 0;\n        for elf in &elves {\n            sum += recipes[*elf];\n        }\n\n        let mut new_recipes = Vec::new();\n\n        if sum == 0 {\n            new_recipes.push(0);\n        }\n        while sum > 0 {\n            new_recipes.push(sum % 10);\n            sum /= 10;\n        }\n\n        while !new_recipes.is_empty() {\n            recipes.push(new_recipes.pop().unwrap());\n        }\n\n        for elf in &mut elves {\n            *elf = (*elf + recipes[*elf] + 1) % recipes.len()\n        }\n\n        if   !find_occurrence && recipes.len() >= input + 10\n           || find_occurrence && check_recipes(&recipes, input) != 0 {\n            break;\n        }\n    }\n\n    if !find_occurrence {\n        \n        let mut ans: u64 = 0;\n        for i in 0..10 {\n            ans = ans*10 + recipes[input + i] as u64;\n        }\n        ans\n    } else {\n        check_recipes(&recipes, input)\n    }\n}\n\nfn main() {\n    println!(\"Score: {}\", run_simulation(360781, false));\n    println!(\"At: {}\", run_simulation(360781, true));\n}\n", "entry_point": "run_simulation"}
{"task_id": "rust_18", "code": "use std::collections::HashMap;\nuse std::num::ParseIntError;\nuse std::str::FromStr;\n\n#[derive(Debug)]\nstruct Reaction {\n    input: HashMap<String, usize>,\n    output: (String, usize),\n}\n\n#[derive(Debug)]\nenum ParseError {\n    Int(ParseIntError),\n    Empty,\n}\n\nimpl From<ParseIntError> for ParseError {\n    fn from(e: ParseIntError) -> Self {\n        ParseError::Int(e)\n    }\n}\n\nimpl FromStr for Reaction {\n    type Err = ParseError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let mut iter = s.split(\"=>\");\n        let ing = iter.next().ok_or(ParseError::Empty)?;\n        let ing: String = ing.replace(\",\", \" \");\n        let out = iter.next().ok_or(ParseError::Empty)?;\n\n        let mut input = HashMap::new();\n        let mut it = ing.split_whitespace();\n        while let Some(s) = it.next() {\n            let cnt = s.parse()?;\n            let name = it.next().ok_or(ParseError::Empty)?;\n            input.insert(name.into(), cnt);\n        }\n\n        let mut it = out.split_whitespace();\n        let cnt = it.next().ok_or(ParseError::Empty)?.parse::<usize>()?;\n        let name = it.next().ok_or(ParseError::Empty)?;\n\n        Ok(Reaction {\n            input,\n            output: (name.into(), cnt),\n        })\n    }\n}\n\n\nfn produce(\n    name: &str,\n    amount: usize,\n    rules: &HashMap<String, Reaction>,\n    resources: &mut HashMap<String, usize>,\n) -> usize {\n    let r = &rules[name];\n    let mut ore_cnt = 0;\n\n    let mut produced = 0;\n\n    if let Some(&o) = r.input.get(\"ORE\") {\n        let times = (amount + r.output.1 - 1) / r.output.1;\n        ore_cnt += o * times;\n        produced += r.output.1 * times;\n    } else {\n        let times = (amount + r.output.1 - 1) / r.output.1;\n        for (n, &c) in &r.input {\n            let need = c * times;\n            let have = *resources.get(n).unwrap_or(&0);\n            if have < need {\n                ore_cnt += produce(&n, need - have, rules, resources);\n            }\n\n            \n            let r = resources.get_mut(n).unwrap();\n            *r -= need;\n        }\n        produced += r.output.1 * times;\n    }\n\n    let r = resources.entry(name.into()).or_insert(0);\n    *r += produced;\n    ore_cnt\n}\n\nfn main() {\n    let instr = std::fs::read_to_string(\"input\").unwrap();\n    let rules: HashMap<String, Reaction> = instr\n        .lines()\n        .map(|l| {\n            let r: Reaction = l.parse().unwrap();\n            (r.output.0.clone(), r)\n        })\n        .collect();\n\n    let mut resources = HashMap::new();\n    let p1 = produce(\"FUEL\", 1, &rules, &mut resources);\n    println!(\"Part 1: {}\", p1);\n\n    let tgt: usize = 1_000_000_000_000;\n    let mut begin = 0;\n    let mut end = 2 *(tgt / p1);\n\n    loop {\n        let mid = (end + begin) / 2;\n        let ore = produce(\"FUEL\", mid, &rules, &mut HashMap::new());\n        let ore_n = produce(\"FUEL\", mid + 1, &rules, &mut HashMap::new());\n\n        if ore < tgt && ore_n > tgt {\n            println!(\"Part 2: {}\", mid);\n            break;\n        } else if ore_n > tgt {\n            end = mid - 1;\n        } else if ore_n < tgt {\n            begin = mid + 1;\n        } else {\n            panic!(\"NOPE\");\n        }\n    }\n}\n", "entry_point": "produce"}
{"task_id": "rust_19", "code": "use std::io;\n\nfn repeating(digits: &Vec<u8>) -> bool {\n    let mut prev = digits[0];\n    for &i in digits.iter().skip(1).take(digits.len() - 2) {\n        if prev == i {\n            return true;\n        }\n        prev = i;\n    }\n    false\n}\n\n\nfn comp_func() {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n\n    let mut limits = input.trim().split('-').map(|x| x.chars().map(|y| y.to_digit(10).unwrap() as u8).collect());\n    let mut current: Vec<u8> = limits.next().unwrap();\n    for i in 1..current.len() {\n        if current[i] < current[i - 1] {\n            current[i] = current[i - 1];\n        }\n    }\n    let end: Vec<u8> = limits.next().unwrap();\n    let mut count: u32 = 0;\n    'mainloop: loop {\n        for (n, &i) in current.iter().enumerate() {\n            if i > end[n] {\n                break 'mainloop;\n            } else if n == current.len() - 1 {\n                if repeating(&current) {\n                    count += (end[n] - i + 1) as u32;\n                } else {\n                    count += 1;\n                }\n                break 'mainloop;\n            } else if i < end[n] {\n                break;\n            }\n        }\n\n        if repeating(&current) {\n            count += (10 - current[current.len() - 1]) as u32;\n        } else {\n            count += 1;\n        }\n\n        let last = current.last_mut().unwrap();\n        *last = 9;\n        for i in current.iter_mut().rev() {\n            *i += 1;\n            if *i > 9 {\n                *i = 0;\n            } else {\n                break;\n            }\n        }\n        for i in 1..current.len() {\n            if current[i] < current[i - 1] {\n                current[i] = current[i - 1];\n            }\n        }\n    }\n    println!(\"{}\", count);\n}\n\nfn main() {\n    comp_func();\n}\n", "entry_point": "comp_func"}
{"task_id": "rust_20", "code": "use std::io;\nuse std::collections::HashMap;\n\n\nfn comp_func() {\n    let mut ints: Vec<i32> = Vec::new();\n    let mut int_mode: HashMap<i32, usize> = HashMap::new();\n\n    loop {\n    \tlet mut buffer = String::new();\n    \tio::stdin()\n            .read_line(&mut buffer)\n            .expect(\"error reading input\");\n        let int_string = buffer.trim();\n        if int_string == \"\" {\n        \tbreak;\n        };\n\n\n        let int = int_string.parse().expect(\"Cannot parse!\");\n        ints.push(int);\n\n        let count = int_mode.entry(int).or_insert(0);\n        *count += 1;\n    };\n\n    ints.sort();\n\n    let mut avg: f64 = 0.0;\n    for int in &ints {\n    \tavg += f64::from(*int);\n    };\n    let n = ints.len();\n    avg /= n as f64;\n\n    let median: f64;\n    let mid_point = n / 2;\n    if n % 2 == 0 {\n    \tmedian = (f64::from(ints[mid_point]) + f64::from(ints[mid_point + 1])) / 2.0;\n    } else {\n    \tmedian = f64::from(ints[mid_point]);\n    }\n\n    let mut mode = 0;\n    let mut max_count: usize = 0;\n    for (int, count) in &int_mode {\n    \tif *count > max_count {\n    \t\tmax_count = *count;\n    \t\tmode = *int;\n    \t}\n    }\n\n    println!(\"Average: {}\", avg);\n    println!(\"Median: {}\", median);\n    println!(\"Mode: {}\", mode);\n}\n\nfn main() {\n    comp_func();\n}\n", "entry_point": "comp_func"}
