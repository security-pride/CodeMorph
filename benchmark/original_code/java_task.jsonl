{"task_id": "java_1", "code": "package boj_february;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class BOJ_17135_teacher {\n\tprivate static int R, C, D;\n\tprivate static int [][] map;\n\tprivate static int MAX = Integer.MIN_VALUE;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tscanner = new Scanner(src);\n\t\tR = scanner.nextInt();\n\t\tC = scanner.nextInt();\n\t\tD = scanner.nextInt();\n\t\t\n\t\tmap = new int[R][C];\n\t\tfor(int r=0; r<R; r++) {\n\t\t\tfor(int c=0; c<C; c++) {\n\t\t\t\tmap[r][c]=scanner.nextInt();\n\t\t\t}\n\t\t}\n\n\t\tcombination(0, new int[3], 0, 0);\n\t\t\n\t\tSystem.out.println(MAX);\n\t}\n\n\n\tpublic static void attack(int [] positions) {\n\t\t\n\t\tList<Enemy> enemies = new ArrayList<>();\n\t\tfor(int r=0; r<R; r++) {\n\t\t\tfor(int c=0; c<C; c++) {\n\t\t\t\tif(map[r][c]==1) {\n\t\t\t\t\tenemies.add(new Enemy(r, c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint deadMan = 0;\n\t\twhile(true) {\n\t\t\t\n\t\t\tfor(int i=0; i<positions.length; i++) {\n\t\t\t\tint archer = positions[i];\n\t\t\t\tPriorityQueue<Enemy> targetedEnemies = new PriorityQueue<>();\n\t\t\t\t\n\t\t\t\tfor(int e=0; e<enemies.size(); e++) {\n\t\t\t\t\tEnemy enemy = enemies.get(e);\n\t\t\t\t\t\n\t\t\t\t\tenemy.d = Math.abs(archer - enemy.c) + Math.abs(enemy.r - R);\n\t\t\t\t\t\n\t\t\t\t\tif(enemy.d <=D) {\n\t\t\t\t\t\ttargetedEnemies.offer(enemy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!targetedEnemies.isEmpty()) {\n\t\t\t\t\ttargetedEnemies.poll().isTargeted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(int e=0; e<enemies.size(); e++) {\n\t\t\t\tEnemy enemy = enemies.get(e);\n\t\t\t\tif(enemy.isTargeted) {\n\t\t\t\t\tenemies.remove(e--);\n\t\t\t\t\tdeadMan++;\n\t\t\t\t}else if(enemy.r==R-1){\t\n\t\t\t\t\tenemies.remove(e--);\n\t\t\t\t}else {\n\t\t\t\t\tenemy.r++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(enemies.size()==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tMAX = Integer.max(MAX, deadMan);\n\t}\n\n\tpublic static void combination(int r, int [] temp, int ti, int si) {\n\t\tif(r==3) {\n\t\t\t\n\t\t\tattack(temp);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=si; i<C; i++) {\n\t\t\ttemp[ti] = i;\n\t\t\tcombination(r+1, temp, ti+1, i+1);\n\t\t}\n\t}\n\t\n\tstatic class Enemy implements Comparable<Enemy>{\n\t\tInteger r, c, d;\n\t\tboolean isTargeted;\n\t\tpublic Enemy(Integer r, Integer c) {\n\t\t\tsuper();\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Enemy o) {\n\t\t\tif(this.d.equals(o.d)) {\n\t\t\t\treturn this.c.compareTo(o.c);\n\t\t\t}else {\n\t\t\t\treturn this.d.compareTo(o.d);\n\t\t\t}\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"[r=\" + r + \", c=\" + c + \"]\";\n\t\t}\n\t}\n\t\n\tprivate static String src = \"5 5 2\\r\\n\" + \n\t\t\t\"0 0 0 0 0\\r\\n\" + \n\t\t\t\"0 0 0 0 0\\r\\n\" + \n\t\t\t\"0 0 0 0 0\\r\\n\" + \n\t\t\t\"1 1 1 1 1\\r\\n\" + \n\t\t\t\"0 0 0 0 0\";\n}\n", "entry_point": "attack"}
{"task_id": "java_2", "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    \n    public static void compFunc(String[] args) throws IOException {\n\n        Scanner in = new Scanner(System.in);\n\n        while (in.hasNext()) {\n            int n = in.nextInt();\n            int g = in.nextInt();\n\n            int[] results = new int[n];\n            int points = 0;\n\n            \n            for (int i = 0; i < n; i++) {\n                byte s = in.nextByte();\n                byte r = in.nextByte();\n\n                results[i] = s - r;\n            }\n\n            Arrays.sort(results);\n\n            \n            for (int i = n - 1; i > -1; i--) {\n                if (results[i] > 0) { \n                    points += 3;\n                } else if (results[i] == 0) { \n                    if (g > 0) {\n                        g--;\n                        points += 3;\n                    } else {\n                        points += 1;\n                    }\n                } else { \n                    int result = g + results[i];\n\n                    if (g > 0) {\n                        if (result == 0) {\n                            points += 1;\n                            break;\n                        } else if (result > 0) {\n                            points += 3;\n                            g += results[i] - 1;\n                        } else {\n                            break;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            \n            System.out.println(points);\n        }\n\n        in.close();\n    }\n\n}\n", "entry_point": "compFunc"}
{"task_id": "java_3", "code": "import java.util.*;\npublic class Main implements Comparator< Integer> { \n  static class Edge{  \n   int e,c;\n   Edge next;\n   Edge rev;  \n  public void dec(int f){\n   c-=f;\n   rev.c+=f;\n  }\n }\n\n int n,m,src,tag;\n final Edge[] g=new Edge[200];\n final int[] h=new int[200];  final int[] ex=new int[200];\n final Scanner sc=new Scanner(System.in);\n final PriorityQueue< Integer> pq=new PriorityQueue< Integer>(200,this);\n\n boolean init(){ \n   if(!sc.hasNext()) return false;\n   m=sc.nextInt();\n   n=sc.nextInt();\n   src=0;   tag=n-1;\n  for(int i=0;i!=n;++i){\n   g[i]=null;\n   h[i]=0;\n   ex[i]=0;\n   }\n\n  h[src]=n;\n  for(int i=0;i!=m;++i){\n   int a=sc.nextInt()-1,b=sc.nextInt()-1,c=sc.nextInt();\n   Edge e0=addEdge(a, b, c),e1=addEdge(b,a,0);\n   e0.rev=e1;e1.rev=e0;\n  }    return true; \n }\n\n  private Edge addEdge(int s, int e, int c) {\n   Edge n=new Edge();\n   n.c=c;\n   n.e=e;\n   n.next=g[s];\n   g[s]=n;\n  return n;\n  }\n\n\n  int work(){\n   for(Edge e=g[src];e!=null;e=e.next){\n    ex[e.e]+=e.c;\n    e.dec(e.c);\n    if(e.e!=src&&e.e!=tag){\n     pq.add(e.e);\n   }\n  }\n  while(pq.size()>0){\n   int v=pq.poll();\n   int exv=ex[v],hv=h[v];\n   for(Edge e=g[v]; exv>0&&e!=null; e=e.next){  \n      if(e.c<=0 || hv !=h[e.e]+ 1 ) continue;\n    int f=Math.min( exv , e.c);\n    ex[e.e]+=f;\n    exv-=f;\n    e.dec(f);\n    if(ex[e.e]==f&&e.e!=tag&&e.e!=src){\n     pq.add(e.e);\n    }\n   }\n   if(exv>0){\n    for(Edge e=g[v];e!=null;e=e.next){\n     if(e.c > 0 && hv>h[e.e]){\n      hv=h[e.e];\n     }\n    }\n    ++hv;\n    pq.add(v);\n   }\n   ex[v]=exv;\n   h[v]=hv;\n  }\n  return ex[tag];\n }\n\n  void go(){     while(init()){\n    System.out.println( work());\n  }\n  }\n\n  public static void main(String[] args) {\n    new Main().go();\n  }\n\n  public int compare(Integer o1, Integer o2) {\n   return h[o2]-h[o1];\n  }\n}", "entry_point": "work"}
{"task_id": "java_4", "code": "\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution {\n\n    \n    public static void compFunc(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        \n        ArrayList<Integer[]> alist = new ArrayList<Integer[]>();\n        \n        for(int i = 0; i < n; i++) {\n            int no_of_ele = scanner.nextInt();\n            \n            Integer [] intarr = new Integer[no_of_ele];\n            \n            for(int j = 0; j < no_of_ele; j++) {\n                int ele = scanner.nextInt();\n                intarr[j] = ele;\n            }\n            alist.add(intarr);\n\n        }\n   \n        int q = scanner.nextInt();\n        int [][] qarr = new int [q][2];\n        \n        for(int i = 0; i < q; i++) {\n            for(int j = 0; j < 2; j++) {\n                qarr[i][j] = scanner.nextInt();\n            }\n        }\n        \n        for(int i = 0; i < q; i++) {\n            int index = qarr[i][0] - 1;\n            int pos = qarr[i][1] - 1;\n            \n            Integer [] arr = alist.get(index);\n            if((arr.length == 0) || (pos >= arr.length)) {\n                System.out.println(\"ERROR!\");\n                continue;\n            }\n            int retrieveEle = arr[pos];\n            System.out.println(retrieveEle);\n        }\n        \n        \n        \n    }\n}", "entry_point": "compFunc"}
{"task_id": "java_5", "code": "package gcj.y2016.round2;\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class C {\n\tstatic final String NO = \"IMPOSSIBLE\";\n\t\n\tint hei, wid, p;\n\tint[] a;\n\t\n    \n\tString solve() {\n\t\tint[] bx = new int[p];\n\t\tint[] by = new int[p];\n\t\tfor (int i = 0; i < wid; i++) {\n\t\t\tbx[i] = 2 * i + 1;\n\t\t\tby[i] = 0;\n\t\t\tbx[hei + wid + i] = 2 * wid - 2 * i - 1;\n\t\t\tby[hei + wid + i] = 2 * hei;\n\t\t}\n\t\tfor (int i = 0; i < hei; i++) {\n\t\t\tbx[wid + i] = 2 * wid;\n\t\t\tby[wid + i] = 2 * i + 1;\n\t\t\tbx[hei + 2 * wid + i] = 0;\n\t\t\tby[hei + 2 * wid + i] = 2 * hei - 2 * i - 1;\n\t\t}\n\t\tchar[][] ans = new char[hei][wid];\n\t\tboolean[] connected = new boolean[p];\n\t\tint[] pair = new int[p];\n\t\tfor (int i = 0; i < p; i += 2) {\n\t\t\ta[i]--;\n\t\t\ta[i + 1]--;\n\t\t\tpair[a[i]] = a[i + 1];\n\t\t\tpair[a[i + 1]] = a[i];\n\t\t}\n\t\tfor (int turn = 0; turn < p / 2; turn++) {\n\t\t\tint from = -1, to = -1;\n\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\tif (connected[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint j = i;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tj = (j + 1) % p;\n\t\t\t\t\tif (connected[j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == pair[i]) {\n\t\t\t\t\tfrom = i;\n\t\t\t\t\tto = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (from == -1) {\n\t\t\t\treturn NO;\n\t\t\t}\n\t\t\tconnected[from] = connected[to] = true;\n\t\t\tint x = bx[from];\n\t\t\tint y = by[from];\n\t\t\tint dx, dy;\n\t\t\tif (x == 0) {\n\t\t\t\tdx = dy = -1;\n\t\t\t} else if (y == 0) {\n\t\t\t\tdx = 1; dy = -1;\n\t\t\t} else if (x == 2 * wid) {\n\t\t\t\tdx = dy = 1;\n\t\t\t} else {\n\t\t\t\tdx = -1; dy = 1;\n\t\t\t}\n\t\t\twhile (x != bx[to] || y != by[to]) {\n\t\t\t\tboolean ok = false;\n\t\t\t\tfor (int t = 0; t <= 2; t++) {\n\t\t\t\t\tint dxNew = -dy;\n\t\t\t\t\tint dyNew = dx;\n\t\t\t\t\tdx = dxNew;\n\t\t\t\t\tdy = dyNew;\n\t\t\t\t\tif (x + dx < 0 || x + dx > 2 * wid || y + dy < 0 || y + dy > 2 * hei) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint x2 = Math.min(x, x + dx) / 2;\n\t\t\t\t\tint y2 = Math.min(y, y + dy) / 2;\n\t\t\t\t\tchar drawn = (dx == dy) ? '\\\\' : '/';\n\t\t\t\t\tif (ans[y2][x2] == drawn || ans[y2][x2] == 0) {\n\t\t\t\t\t\tans[y2][x2] = drawn;\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ok) {\n\t\t\t\t\treturn NO;\n\t\t\t\t}\n\t\t\t\tx += dx;\n\t\t\t\ty += dy;\n\t\t\t\tdx *= -1;\n\t\t\t\tdy *= -1;\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < hei; i++) {\n\t\t\tsb.append(new String(ans[i]).replace((char) 0, '/')).append(\"\\n\");\n\t\t}\n\t\treturn sb.toString().trim();\n\t}\n\t\n\tpublic C(Scanner in) {\n\t\thei = in.nextInt();\n\t\twid = in.nextInt();\n\t\tp = 2 * (hei + wid);\n\t\ta = new int[p];\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tint nThreads = 1;\n\t\t\n\t\tString fileNameSuffix = \"\";\n\t\tString formatOut = \"Case #%2$d:\\n%1$s\";\n\t\tString formatSystemOut = formatOut;\n\n\n\n\n\t\t\n\t\tString fileName = C.class.getSimpleName().replaceFirst(\"_.*\", \"\").toLowerCase() + fileNameSuffix;\n\t\tString inputFileName = fileName + \".in\";\n\t\tString outputFileName = fileName + \".out\";\n\t\t\n\t\tLocale.setDefault(Locale.US);\n\t\tScanner in = new Scanner(new File(inputFileName));\n\t\tPrintWriter out = new PrintWriter(outputFileName);\n\t\tint tests = in.nextInt(); in.nextLine();\n\t\tnThreads = Math.min(nThreads, tests);\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tCallable<String>[] callables = new Callable[tests];\n\t\tfor (int t = 0; t < tests; t++) {\n\t\t\tfinal C testCase = new C(in);\n\t\t\tfinal int testCaseNumber = t + 1;\n\t\t\tcallables[t] = new Callable<String>() {\n\t\t\t\t@Override\n\t\t\t\tpublic String call() {\n\t\t\t\t\tString answer = testCase.solve();\n\t\t\t\t\tSystem.out.println(String.format(formatSystemOut, answer, testCaseNumber));\n\t\t\t\t\treturn String.format(formatOut, answer, testCaseNumber);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\ttry {\n\t\t\tif (nThreads > 1) {\n\t\t\t\tExecutorService executor = Executors.newFixedThreadPool(4);\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tFuture<String>[] outputs = new Future[tests];\n\t\t\t\tfor (int t = 0; t < tests; t++) {\n\t\t\t\t\toutputs[t] = executor.submit(callables[t]);\n\t\t\t\t}\n\t\t\t\tfor (int t = 0; t < tests; t++) {\n\t\t\t\t\tout.println(outputs[t].get());\n\t\t\t\t}\n\t\t\t\texecutor.shutdown();\n\t\t\t} else {\n\t\t\t\tfor (int t = 0; t < tests; t++) {\n\t\t\t\t\tout.println(callables[t].call());\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.flush();\n\t\t\tSystem.err.flush();\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t\tSystem.out.println(\"COMPLETE\");\n\t\tin.close();\n\t\tout.close();\n\t}\n}\n", "entry_point": "solve"}
{"task_id": "java_6", "code": "package com.elfefe.fonctionne.mathengine.special;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\nimport java.util.List;\n\npublic final class Primes {\n\tpublic static List<Long> distinctPrimeFactors(long n) {\n\n\t\tList<Long> factors = primeFactors(n);\n\t\tLinkedHashSet<Long> distinct = new LinkedHashSet<>(factors);\n\n\t\treturn new ArrayList<Long>(distinct);\n\t}\n\n\tpublic static boolean isPrime(long n) {\n\t\tn = Math.abs(n);\n\n\t\tboolean prime = true;\n\t\tfor (long i = 3; i <= Math.sqrt(n); i += 2) {\n\n\t\t\tif (n % i == 0) {\n\t\t\t\tprime = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((n % 2 != 0 && prime && n > 2) || n == 2) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static long nextPrime(long n) {\n\t\tn++;\n\t\tif (n % 2 == 0) {\n\t\t\tn++;\n\t\t}\n\n\t\tlong result = n;\n\n\t\twhile (!isPrime(result)) {\n\t\t\tresult += 2;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic static long previousPrime(long n) {\n\t\tn--;\n\t\tif (n % 2 == 0) {\n\t\t\tn--;\n\t\t}\n\n\t\tlong result = n;\n\t\twhile (!isPrime(result)) {\n\t\t\tresult -= 2;\n\t\t}\n\n\t\treturn result;\n\t}\n    \n\tpublic static List<Long> primeFactors(long n) {\n\t\tlong num = Math.abs(n);\n\n\t\tList<Long> factors = new ArrayList<Long>();\n\n\t\tif (num == 1) {\n\t\t\tfactors.add(num);\n\t\t}\n\n\t\tfor (long i = 2; i <= num / i; i++) {\n\t\t\twhile (num % i == 0){\n\t\t\t\tfactors.add(i);\n\t\t\t\tnum /= i;\n\t\t\t}\n\t\t}\n\n\t\tif (num >= 0 && num != 1) {\n\t\t\tfactors.add(num);\n\t\t}\n\n\t\tif (n < 0 && factors.size() != 0) {\n\t\t\tlong first = factors.get(0);\n\n\t\t\tfor (int i = 0; i < factors.size(); i++) {\n\t\t\t\tlong current = factors.get(i);\n\n\t\t\t\tif (current == first)\n\t\t\t\t\tfactors.set(i, -current);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn factors;\n\t}\n}\n", "entry_point": "primeFactors"}
{"task_id": "java_7", "code": "package subArraySum;\nimport java.util.Arrays;\n\npublic class subArraySum {\n\n    public static void subArraySumGreed(int[] arr, int k) {\n        for (int i = 0; i < arr.length; i += 1) {\n            int sum = 0;\n            for (int j = i; j < arr.length; j += 1) {\n                sum += arr[j];\n                if (sum == k) {\n                    System.out.println(Arrays.toString(Arrays.copyOfRange(arr, i, j + 1)));\n                }\n            }\n        }\n    }\n\n    public static int subArraySumKadane(int[] arr, int k) {\n        int best = 0;\n        int current = 0;\n        for (int i = 0; i < arr.length; i += 1) {\n            current = Math.max(0, current + arr[i]);\n            best = Math.max(current, best);\n        }\n        return best;\n    }\n\n    \n    public static int[] subArraySumKadaneK(int[] arr, int k) {\n        int current = arr[0];\n        int i = 0;\n        int j = 0;\n        while (j < arr.length) {\n            if (current == k) {\n                return Arrays.copyOfRange(arr, i, j + 1);\n            }\n            if (current < k) {\n                j += 1;\n                if (j < arr.length) {\n                    current += arr[j];\n                }\n            } else { \n                current = current - arr[i];\n                i += 1;\n            }\n        }\n        return Arrays.copyOfRange(arr, i, j);\n    }\n\n    public static void main(String[] args) {\n        subArraySumGreed(new int[] { 1, 2, 3, 4, 1, 7 }, 12); \n        System.out.println(Arrays.toString(subArraySumKadaneK(new int[] { 2, 4, 17, 9, 6, 3 }, 18))); \n        System.out.println(subArraySumKadane(new int[] { 1, 2, 3, 4, 1, 7 }, 12)); \n    }\n}", "entry_point": "subArraySumKadaneK"}
{"task_id": "java_8", "code": "\n\n\npackage net.wastl.webmail.misc;\n\nimport java.util.Properties;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Enumeration;\n\npublic class ExpandableProperties extends Properties {\n    static final long serialVersionUID = -6501669686410348173L;\n\n    Pattern propVarPattern = Pattern.compile(\"\\\\Q${\\\\E([^}]+?)\\\\Q}\");\n    private boolean permitUnset = false;\n    private boolean namesToo = false;\n    private boolean sysToo = true;\n\n\n    \n    public void expand(Properties inExp, boolean permitUnset,\n            boolean namesToo, boolean sysToo) {\n        Properties exp = (sysToo ? (new Properties(System.getProperties()))\n                                 : (new Properties()));\n        exp.putAll(inExp);\n        Properties additions = new Properties();\n        Set<String> zaps = new HashSet<String>(); \n\n        Enumeration e = propertyNames();\n        String pk, pv;\n        String newKey, newVal;\n        Matcher m;\n        while (e.hasMoreElements()) {\n            pk = (String) e.nextElement();\n            pv = getProperty(pk);\n            newKey = null;\n            if (namesToo) {\n                m = propVarPattern.matcher(pk);\n                if (m.find()) newKey = subst(m, pk, exp, permitUnset);\n            }\n            m = propVarPattern.matcher(pv);\n            newVal = (m.find() ? subst(m, pv, exp, permitUnset) : null);\n            if (newKey != null) zaps.add(pk);\n            if (newKey != null || newVal != null)\n                additions.setProperty(((newKey == null) ? pk : newKey),\n                    ((newVal == null) ? pv : newVal));\n        }\n        for (String k : zaps) remove(k);\n        putAll(additions);\n    }\n\n    protected String subst(Matcher m, String origVal,\n            Properties exp, boolean permitUnset) {\n        int afterLast = 0;\n        String substVal;\n        StringBuilder sb = new StringBuilder();\n        do {\n            substVal = exp.getProperty(m.group(1));\n            if (substVal == null) {\n                if (permitUnset) continue;\n                throw new IllegalStateException(\n                        \"Undefined property '\" + m.group(1) + \"'\");\n            }\n            sb.append(origVal.substring(afterLast, m.start())\n                    + substVal);\n            afterLast = m.end();\n        } while (m.find());\n        sb.append(origVal.substring(afterLast));\n        if (origVal.equals(sb.toString())) return null;\n        \n        return sb.toString();\n    }\n}\n", "entry_point": "expand"}
{"task_id": "java_9", "code": "package practice.slidingwindow;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FindFirstNegative {\n  \n  \n  public List<Integer> findFirstNegative(int[] arr, int k) {\n    List<Integer> output = new ArrayList<>();\n    int i = 0, j = 0;\n    List<Integer> negativeList = new ArrayList<>();\n    while (j < arr.length) {\n      if (arr[j] < 0) {\n        negativeList.add(arr[j]);\n      }\n      if (j - i + 1 < k) {\n        j++;\n      } else if (j - i + 1 == k) {\n        if (negativeList.isEmpty()) {\n          output.add(0);\n        } else {\n          output.add(negativeList.get(0));\n          if (arr[i] == negativeList.get(0)) {\n            negativeList.remove(0);\n          }\n        }\n        i++;\n        j++;\n      }\n    }\n    return output;\n  }\n\n\n  public static void main(String[] args) {\n    FindFirstNegative findMax = new FindFirstNegative();\n    int[] arr = new int[]{2, -1, -7, 8, -15, 30, 9, 1};\n    int k = 3;\n    findMax.findFirstNegative(arr, k).forEach(System.out::println);\n  }\n}\n", "entry_point": "findFirstNegative"}
{"task_id": "java_10", "code": "\npackage stats;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class WilcoxonSignedRanksTest {\n    \n    private double MIN=-1.0;\n    \n    public WilcoxonSignedRanksTest()\n    {\n        \n    }\n    \n    public void test()\n    {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n       String s;\n       int i=0;\n       double values1[] = new double[6];\n       double values2[] = new double[6];\n       \n        try {\n            while ((s = in.readLine()) != null && s.length() != 0){\n               String values[] = s.split(\"\\\\s+\");\n                    \n               values1[i] = Double.parseDouble(values[0]);\n               values2[i] = Double.parseDouble(values[1]);\n\n               i++;\n    \n            }\n            \n            performTest(values1, values2);\n        } catch (IOException ex) {\n            Logger.getLogger(WilcoxonSignedRanksTest.class.getName()).log(Level.SEVERE, null, ex);\n        }\n   }\n    \n    \n    public int [] nextMinIndexes(double []acc,double min)\n    {\n\tint [] ids=new int[acc.length];\n\tint j=0;\n\tdouble m=1.0;\n\n\tfor(int i=0;i<acc.length;i++)\n\t    acc[i] = Math.abs(acc[i]);\n\n\tfor(int i=0;i<acc.length;i++)\n\t    if(acc[i]>min && m>acc[i])\n\t\tm = acc[i];\n\n\tfor(int i=0;i<acc.length;i++)\n\t    if(Math.abs(acc[i])==m)\n\t    {\n\t\tids[j]=i;\n\t\tj++;\n\t    }\n\n\tint [] rids = new int[j];\n\tfor(int i=0;i<j;i++)\n\t{\n\t    rids[i] = ids[i];\n\t}\n\tMIN = acc[rids[0]];\n\n\treturn rids;\n    }\n\n\n    public double [] performTest(double [] m1, double [] m2)\n    {\n\tint l = m1.length;\n\tint l2 = m2.length;\n\n\tif(l != l2)\n\t{\n\t    System.out.println(\"The tables are not equalsized\");\n\t    System.exit(0);\n\t}\n\n\tint max_rank = l;\n\tint rank=1;\n\tint [] ids = new int[l];\n\n\tdouble mean_rank;\n\tdouble [] dif = new double[l];\n\tdouble [] ranks = new double[l];\n\n\tfor(int i=0;i<l;i++)\n\t    dif[i] = m1[i]-m2[i];\n\n\twhile(rank<=max_rank)\n\t{\n\t    ids = nextMinIndexes(dif.clone(),MIN);\n\n\t    mean_rank = 0.0;\n\n\t    for(int j=0;j<ids.length;j++)\n\t    {\n\t\tmean_rank = mean_rank + rank;\n\t\trank+=1;\n\t    }\n\t    mean_rank/=ids.length;\n\n\t    for(int j=0;j<ids.length;j++)\n\t    {\n\t\tmean_rank = Math.round(mean_rank*1000)/1000.0;\n\t\tranks[ids[j]]=mean_rank;\n\t    }\n\n\t}\n\n\tdouble rminus=0.0;\n\tdouble rpos = 0.0;\n\tdouble rzero = 0.0;\n\tdouble rankzero = 0;\n\tint countzeros=0;\n\n\tfor(int i=0;i<l;i++)\n\t{\n\t    if(dif[i]<0.0)\n\t\trminus+=ranks[i];\n\t    else if(dif[i]>0.0)\n\t\trpos+=ranks[i];\n\t    else\n\t    {\n\t\trankzero = ranks[i];\n\t\trzero += ranks[i];\n\t\tcountzeros+=1;\n\t    }\n\t}\n\n\tif(countzeros%2!=0)\n\t    rzero-=rankzero;\n\t\n\trpos+=rzero/2.0;\n\trminus+=rzero/2.0;\n\n\tSystem.out.println(\"R+: \"+rpos+\" R-: \"+rminus);\n\tSystem.out.println(\"T = \"+Math.min(rpos,rminus));\n\n\treturn ranks;\n    }\n    \n    public static void main(String args[])\n    {\n        WilcoxonSignedRanksTest stest = new WilcoxonSignedRanksTest();\n        stest.test();\n    }\n}\n", "entry_point": "nextMinIndexes"}
{"task_id": "java_11", "code": "package dsf.algorithm.leetcode.weekly.c174;\n\nimport java.util.PriorityQueue;\n\n\npublic class P1 {\n\n    \n    public int[] kWeakestRows(int[][] mat, int k) {\n\n        PriorityQueue<Node> queue = new PriorityQueue<>((n1, n2) -> {\n            if (n1.n < n2.n)\n                return -1;\n            if (n1.n > n2.n)\n                return 1;\n            return Integer.compare(n1.i, n2.i);\n        });\n\n        for (int i=0; i<mat.length; i++) {\n            int n = 0;\n            int[] arr = mat[i];\n            for (; n<arr.length && arr[n] == 1; n++) {}\n            queue.add(new Node(i, n));\n        }\n\n        int[] ans = new int[k];\n        for (int i=0; i<k; i++) {\n            ans[i] = queue.poll().i;\n        }\n        return ans;\n    }\n\n    static class Node {\n        int i, n;\n\n        public Node(int i, int n) {\n            this.i = i;\n            this.n = n;\n        }\n    }\n}\n", "entry_point": "kWeakestRows"}
{"task_id": "java_12", "code": "package array_matrix_sorting;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class SmallestRangeCoveringElementsFromKLists {\n\n    \n    public int[] smallestRange(List<List<Integer>> nums) {\n        List<int[]> list = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            for (int num : nums.get(i)) {\n                list.add(new int[]{num, i});\n            }\n        }\n        Collections.sort(list, (a, b) -> (a[0] - b[0]));\n        int[] res = new int[]{list.get(0)[0], list.get(list.size() - 1)[0]};\n        int start = 0;\n        int end = 0;\n        int[] count = new int[nums.size()];\n        int total = 0;\n        while (end < list.size()) {\n            int[] pair = list.get(end);\n            int index = pair[1];\n            if (count[index] == 0) {\n                total++;\n            }\n            count[index]++;\n            end++;\n            while (start < end && total == nums.size()) {  \n                if (res[1] - res[0] > list.get(end - 1)[0] - list.get(start)[0]) {\n                    res[0] = list.get(start)[0];\n                    res[1] = list.get(end - 1)[0];\n                }\n                int[] prev = list.get(start);\n                int prevIndex = prev[1];\n                count[prevIndex]--;\n                if (count[prevIndex] == 0) {\n                    total--;\n                }\n                start++;\n            }\n        }\n        return res;\n    }\n}\n", "entry_point": "smallestRange"}
{"task_id": "java_13", "code": "package com.github.zmzhoustar;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class AdjacentArray {\n\n\tprivate static final String REGEX = \"[\\\\s,]+\";\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tSystem.out.println(\"\u8bf7\u8f93\u5165\u77e9\u9635\u7684\u5927\u5c0f N \uff1a\");\n\t\twhile (!\"\".equals(line = br.readLine().trim())) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tString[][] input = new String[n][n];\n\t\t\tSystem.out.println(\"\u8bf7\u8f93\u5165N*N\u77e9\u9635\uff1a\");\n\t\t\tfor (int i = 0; i < input.length; i++) {\n\t\t\t\tinput[i] = br.readLine().trim().split(REGEX);\n\t\t\t}\n\t\t\tSystem.out.println(\"\u8bf7\u8f93\u5165\u957f\u5ea6\u4e3aM\u7684\u6570\u7ec4(M > N)\uff1a\");\n\t\t\tString mStr;\n\t\t\twhile (!\"\".equals(mStr = br.readLine().trim())) {\n\t\t\t\tString[] m = mStr.split(REGEX);\n\t\t\t\tSystem.out.println(\"\u662f\u5426\u4e3a\u76f8\u90bb\u6570\u7ec4\u5224\u65ad\u7ed3\u679c\u4e3a\uff1a\" + adjacentArray(input, m));\n\t\t\t\tSystem.out.println(\"\u8bf7\u8f93\u5165\u957f\u5ea6\u4e3aM\u7684\u6570\u7ec4\uff1a\");\n\t\t\t}\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n    \n\tprivate static boolean adjacentArray(String[][] input, String[] m) {\n\t\tMap<String, List<int[]>> map = new LinkedHashMap<>(m.length);\n\t\tfor (String s : m) {\n\t\t\tmap.put(s, new ArrayList<>());\n\t\t}\n\t\tfor (int i = 0; i < input.length; i++) {\n\t\t\tString[] str = input[i];\n\t\t\tfor (int j = 0; j < str.length; j++) {\n\t\t\t\tif (map.containsKey(input[i][j])) {\n\t\t\t\t\tint[] point = new int[]{i, j};\n\t\t\t\t\tList<int[]> value = map.get(input[i][j]);\n\t\t\t\t\tif (!value.isEmpty() && value.contains(point)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvalue.add(point);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<int[]> pointer = map.get(m[0]);\n\t\t\n\t\tif (pointer.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tList<int[]> router = new LinkedList<>();\n\t\tfor (int i = 1; i < m.length; i++) {\n\t\t\tfinal List<int[]> next = map.get(m[i]);\n\t\t\tfor (int[] p : pointer) {\n\t\t\t\tfor (int[] n : next) {\n\t\t\t\t\tboolean requirement =\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t(n[0] - p[0] == 1 && n[1] == p[1]) ||\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t(n[0] == p[0] && n[1] - p[1] == 1) ||\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t(n[0] == p[0] && n[1] - p[1] == -1) ||\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t(n[0] - p[0] == -1 && n[1] == p[1]);\n\t\t\t\t\tif (requirement && addRouter(router, p, n)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tpointer = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn router.size() == m.length;\n\t}\n\n\tprivate static boolean addRouter(List<int[]> router, int[] p, int[] n) {\n\t\t\n\t\tif (router.isEmpty()) {\n\t\t\trouter.add(p);\n\t\t}\n\t\t\n\t\tif (!router.contains(n) && Arrays.equals(router.get(router.size() - 1), p)) {\n\t\t\trouter.add(n);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n", "entry_point": "adjacentArray"}
{"task_id": "java_14", "code": "import java.lang.*;\nimport java.util.Arrays;\n\npublic class BeadSort {\n\n    \n    int[] sort(int[] arr) {\n        int max = 0;\n        for (int i = 0; i < arr.length; i++)\n            if (arr[i] > max)\n                max = arr[i];\n\n        char[][] grid = new char[arr.length][max];\n        int[] counter = new int[max];\n        for (int i = 0; i < max; i++) {\n            counter[i] = 0;\n            for (int j = 0; j < arr.length; j++)\n                grid[j][i] = '_';\n        }\n\n        for (int i = 0; i < arr.length; i++) {\n            int num = arr[i];\n            for (int j = 0; num > 0; j++) {\n                grid[counter[j]++][j] = '*';\n                num--;\n            }\n\n        }\n\n        System.out.println();\n\n        int[] sortingArray = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            int putt = 0;\n            for (int j = 0; j < max && grid[arr.length - 1 - i][j] == '*'; j++)\n                putt++;\n            sortingArray[i] = putt;\n        }\n\n        return sortingArray;\n    }\n\n    void display1D(int[] arr) {\n\n        for (int i = 0; i < arr.length; i++)\n            System.out.print(arr[i] + \" \");\n\n    }\n\n    void display1D(char[] arr) {\n\n        for (int i = 0; i < arr.length; i++)\n            System.out.print(arr[i] + \" \");\n\n    }\n\n    void display2D(char[][] arr) {\n\n        for (int i = 0; i < arr.length; i++)\n            display1D(arr[i]);\n\n    }\n\n}\n", "entry_point": "sort"}
{"task_id": "java_15", "code": "\npackage org.hibnet.webpipes.css;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CssSpliter {\n    \n    public List<String> split(String content) throws Exception {\n        List<String> result = new ArrayList<>();\n\n        StringBuilder current = null;\n        int count = 0;\n        int multiplier = 1;\n        boolean inRule = false;\n        for (int i = 0; i < content.length(); i++) {\n            char c = content.charAt(i);\n            if (c == '{') {\n                inRule = true;\n            }\n            if (c == ',' && !inRule) {\n                multiplier++;\n            }\n            if (c == '}') {\n                count += multiplier;\n                multiplier = 1;\n                inRule = false;\n            }\n            if (count >= 4000 || current == null) {\n                \n                if (current != null) {\n                    result.add(current.toString());\n                }\n                current = new StringBuilder();\n                count = 0;\n            }\n            current.append(c);\n        }\n\n        return result;\n    }\n}\n", "entry_point": "split"}
{"task_id": "java_16", "code": "package com.mohadian;\n\nimport java.util.*;\n\npublic class ThreeSum {\n    \n    private static ArrayList<Integer[]> threeSums(int[] input) {\n        ArrayList<Integer[]> result = new ArrayList<>();\n        Arrays.sort(input);\n\n        int length = input.length;\n        for (int i = 0; i < length - 3; i++) {\n            if (i == 0 || input[i] > input[i - 1]) {\n                int current = input[i];\n                int lower = i + 1;\n                int upper = length - 1;\n                while (lower <= upper) {\n                    int diff = input[upper] + input[lower];\n                    if (diff == -1 * current) {\n                        System.out.println(\"\" + current + \" \" + input[lower] + \" \" + input[upper]);\n                        result.add(new Integer[]{current, input[lower], input[upper]});\n                        break;\n                    } else if (diff < -1 * current) {\n                        do {\n                            lower++;\n                        } while (lower + 1 < length && input[lower] == input[lower + 1]);\n                        if (lower == upper) break;\n                    } else if (diff > -1 * current) {\n                        do {\n                            upper--;\n                        } while (upper > i && input[upper] == input[upper - 1]);\n                        if (upper == lower) break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<Integer[]> findThreeSums(int[] input) {\n        Map<Integer, Integer> elements = new HashMap<>();\n        int length = input.length;\n        Set<Integer[]> result = new HashSet<>();\n\n        Arrays.sort(input);\n\n        for (int i = 0; i < length; i++) {\n            elements.put(input[i], i);\n        }\n\n        for (int i = 0; i < length; i++) {\n            int current = input[i];\n            int complement = -1 * current;\n\n            for (int j = i + 1; j < length; j++) {\n                int second = input[j];\n                if (elements.containsKey(complement - second)) {\n                    if (elements.get(complement - second) != j) {\n                        System.out.println(\"\" + current + \" \" + second + \" \" + (complement - second));\n                        result.add(new Integer[]{current, second, (complement - second)});\n\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] input = new int[]{-1, 0, 1, 2, -1, -1};\n\n        Set<Integer[]> result = findThreeSums(input);\n        Iterator<Integer[]> iterator = result.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(Arrays.toString(iterator.next()));\n        }\n\n        threeSums(input);\n    }\n}\n", "entry_point": "threeSums"}
{"task_id": "java_17", "code": "package com.ywh.problem.leetcode.medium;\n\npublic class LeetCode43 {\n\n    private static String mul(String num1, String num2) {\n        String sum = \"0\";\n        for (int i = num2.length() - 1; i >= 0; i--) {\n            int k = num2.length() - 1 - i, p = 1;\n            while (k > 0) {\n                p *= 10;\n                k--;\n            }\n\n            String cur = \"0\";\n            for (int j = 0; j < p; j++) {\n                cur = add(cur, num1);\n            }\n            String tmp = cur;\n            for (int j = 0; j < (num2.charAt(i) - '0') - 1; j++) {\n                cur = add(cur, tmp);\n            }\n            sum = add(sum, cur);\n        }\n        return sum;\n    }\n\n    private static String add(String num1, String num2) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = num1.length() - 1, j = num2.length() - 1, carry = 0; i >= 0 || j >= 0 || carry > 0;) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num1.charAt(i--) - '0';\n            }\n            if (j >= 0) {\n                sum += num2.charAt(j--) - '0';\n            }\n            sb.append(sum % 10);\n            carry = sum / 10;\n        }\n        return sb.reverse().toString();\n    }\n    \n    public String multiply(String num1, String num2) {\n        String ret = \"0\";\n        if (\"0\".equals(num1) || \"0\".equals(num2)) {\n            return ret;\n        }\n        for (int i = num2.length() - 1; i >= 0; i--) {\n\n            \n            int a = num2.charAt(i) - '0';\n            StringBuilder sb = new StringBuilder();\n            for (int j = num1.length() - 1, k = 1, carry = 0;\n                 j >= 0 || carry != 0;\n                 j--, k *= 10\n            ) {\n                int s = carry;\n                if (j >= 0) {\n                    s += a * (num1.charAt(j) - '0');\n                }\n                sb.append(s % 10);\n                carry = s / 10;\n            }\n            sb.reverse();\n            for (int k = i; k < num2.length() - 1; k++) {\n                sb.append(\"0\");\n            }\n            String cur = sb.toString();\n            sb.delete(0, sb.length());\n\n            \n            for (int p1 = ret.length() - 1, p2 = cur.length() - 1, carry = 0; p1 >= 0 || p2 >= 0 || carry != 0; ) {\n                int sum = carry;\n                if (p1 >= 0) {\n                    sum += ret.charAt(p1) - '0';\n                    p1--;\n                }\n                if (p2 >= 0) {\n                    sum += cur.charAt(p2) - '0';\n                    p2--;\n                }\n                sb.append(sum % 10);\n                carry = sum / 10;\n            }\n            ret = sb.reverse().toString();\n        }\n        return ret;\n    }\n\n}\n", "entry_point": "multiply"}
{"task_id": "java_18", "code": "package com.ssynhtn.medium;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class HandofStraights {\n\n    \n    public boolean isNStraightHandSortedSet(int[] hand, int W) {\n        int n = hand.length;\n        if (n % W != 0) return false;\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\n        for (int x : hand) {\n            counts.merge(x, 1, Integer::sum);\n        }\n\n        while (!counts.isEmpty()) {\n            Map.Entry<Integer, Integer> first = counts.pollFirstEntry();\n            int min = first.getKey();\n            int d = first.getValue();\n\n            for (int i = min + 1; i < min + W; i++) {\n                Integer c = counts.get(i);\n                if (c == null) return false;\n                if (c < d) return false;\n                if (c == d) {\n                    counts.remove(i);\n                } else {\n                    counts.put(i, c - d);\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new HandofStraights().isNStraightHandSortedSet(new int[]{1,2,3,6,2,3,4,7,8}, 3));\n    }\n}\n", "entry_point": "isNStraightHand"}
{"task_id": "java_19", "code": "package leetcode.weekly_contests.weekly_96;\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class P_882 {\n\n    \n    public int reachableNodes(int[][] edges, int maxMoves, int n) {\n        final int[][] g = new int[n][n];\n        final boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(g[i], -1);\n        }\n        for (int[] edge : edges) {\n            g[edge[0]][edge[1]] = edge[2];\n            g[edge[1]][edge[0]] = edge[2];\n        }\n        int res = 0;\n        final PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(b[1], a[1]));\n        pq.offer(new int[] { 0, maxMoves });\n        while (!pq.isEmpty()) {\n            final int[] curr = pq.poll();\n            final int u = curr[0];\n            final int move = curr[1];\n            if (visited[u]) {\n                continue;\n            }\n            visited[u] = true;\n            res++;\n            for (int v = 0; v < n; v++) {\n                if (g[u][v] > -1) {\n                    if (move > g[u][v] && !visited[v]) {\n                        pq.offer(new int[] { v, move - g[u][v] - 1 });\n                    }\n                    g[v][u] -= Math.min(move, g[u][v]);\n                    res += Math.min(move, g[u][v]);\n                }\n            }\n        }\n        return res;\n    }\n}\n", "entry_point": "reachableNodes"}
{"task_id": "java_20", "code": "package math;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\n\npublic class Boj2904 {\n    private static ArrayList<Integer> primes = new ArrayList<>();\n    private static boolean[] prime = new boolean[1_000_001];\n    private static HashMap<Integer, Integer> count = new HashMap<>();\n\n    private static final String SPACE = \" \";\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n\n        eratosthenes();\n        int[] value = new int[N];\n        int size = primes.size();\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < N; i++) {\n            value[i] = Integer.parseInt(st.nextToken());\n            int loop = value[i];\n\n            if(prime[loop]) {\n                adder(loop);\n                continue;\n            }\n            int idx = 0;\n\n            while(idx < size && loop > 0) {                         \n                int current = primes.get(idx++);\n\n                while(loop % current == 0){\n                    adder(current);\n                    loop /= current;\n                }\n            }\n        }\n\n        System.out.println(finding(N, value));\n    }\n\n    private static void adder (int p) {\n        if(count.containsKey(p)) count.put(p, count.get(p) + 1);\n        else count.put(p, 1);\n    }\n\n    private static void eratosthenes() {\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n\n        int loop = 1_001;\n\n        for(int i = 2; i < loop; i++) {\n            if(!prime[i]) continue;\n\n            for(int j = i + i; j < prime.length; j += i) {\n                prime[j] = false;\n            }\n        }\n\n        for(int i = 0; i < prime.length; i++) {\n            if(prime[i]) primes.add(i);\n        }\n    }\n    \n    private static String finding(int n, int[] value) {\n        HashMap<Integer, Integer> p = new HashMap<>();\n        int gcd = 1;\n\n        for(int key: count.keySet()) {                          \n            int dup = count.get(key) / n;\n            if(dup == 0) continue;\n\n            if(p.containsKey(key)) p.put(key, p.get(key) + dup);\n            else p.put(key, dup);\n\n            gcd *= Math.pow(key, dup);\n        }\n\n        int result = 0;\n        for(int i = 0; i < n; i++) {\n            for(int key: p.keySet()) {\n                if(key == 1) continue;\n\n                int cnt = 0;\n                int loop = value[i];\n\n                while(loop % key == 0) {\n                    cnt++;\n                    loop /= key;\n                }\n\n                if(cnt < p.get(key)) result += p.get(key) - cnt;    \n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        return sb.append(gcd).append(SPACE).append(result).toString();\n    }\n}\n", "entry_point": "finding"}
