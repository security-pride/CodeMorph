{"task_id": "cpp_1", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int init(void){\n\tint x;\n\tchar c;\n\tfor(c = getchar(); !isdigit(c); c = getchar());\n\tfor(x = 0; isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x;\n}\n\nbool simple_is_prime(int n){\n\tif(n <= 1)\n\t\treturn false;\n\tif(n == 2 || n == 3)\n\t\treturn true;\n\tif(n % 6 != 1 && n % 6 != 5)\n\t\treturn false;\n\tint t = sqrt(n);\n\tfor(register int i = 5; i <= t; i += 6)\n\t\tif(n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\n\n\nint comp_func()\n{\n\tint k = init();\n\n\twhile(k--){\n\t\tint n = init();\n\t\t\n\t\tif(simple_is_prime(n)){\n\t\t\tint t;\n\t\t\tchar f = 1;\n\t\t\twhile(n && f){\n\t\t\t\tt = 0;\n\t\t\t\tint p = 1;\n\t\t\t\tdo{\n\t\t\t\t\tif(n % 10 == 0){\n\t\t\t\t\t\t\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt = t + n % 10 * p;\n\t\t\t\t\tn /= 10;\n\t\t\t\t\tp *= 10;\n\t\t\t\t}while(n >= 10);\n\t\t\t\tif(!simple_is_prime(t) || t == 0){\n\t\t\t\t\t\n\t\t\t\t\tf = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(n > 10)\n\t\t\t\t\tn = t;\n\t\t\t\telse\n\t\t\t\t\tn = 0;\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tprintf(\"Yes\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"No\\n\");\n\t\t}else{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n    return comp_func();\n}", "entry_point": "comp_func"}
{"task_id": "cpp_2", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1073741824\n\ninline int readchar() {\n    const int N = 4194304;\n    static char buf[N];\n    static char *p = buf, *end = buf;\n    bool fin = 0;\n    if (fin) return EOF;\n    if (p == end) {\n        if ((end = buf + fread(buf, 1, N, stdin)) == buf) {\n            fin = 1;\n            return EOF;\n        }\n        p = buf;\n    }\n    return *p++;\n}\n\ninline bool isdigit(char ch) { return ch>='0' && ch<='9'; }\ninline int readUInt() {\n    char ch;\n    unsigned int r=0;\n    while (!isdigit(ch=readchar()))\n        if (ch == EOF) return EOF;\n    r = ch-'0';\n    while (isdigit(ch=readchar()))\n        r = (r<<3) + (r<<1) + ch-'0';\n\n    while (ch!=' ' && ch!='\\n')\n        ch = readchar();\n    return r;\n}\n\n\nchar D[10017], ID[10017];\nunsigned int UID[117], M[117][117];\n\n\nint comp_func() {\n    vector<int> X[101];\n    for (int i=0; i<101; ++i)\n        X[i].reserve(1000);\n\n    int T = readUInt();\n    while (T--) {\n        int n = readUInt(),\n            r = readUInt();\n\n        int m = 0;\n        memset(D, 0, n+1);\n        for (int i=0; i<r; ++i) {\n            X[i].clear();\n            for (int j; (j=readUInt()); ) {\n                X[i].push_back(j);\n                if (++D[j] == 2)\n                    UID[ID[j] = m++] = j;\n            }\n        }\n\n        for (int i=0; i<m; ++i) {\n            for (int j=0; j<m; ++j)\n                M[i][j] = INF;\n            M[i][i] = 0;\n        }\n\n        for (int i=0; i<r; ++i) {\n            int l=-1, u;\n            for (int k=0; k<X[i].size(); ++k) {\n                int j = X[i][k];\n                if (D[j] > 1) {\n                    int v = ID[j];\n                    if (l!=-1 && k-l<M[u][v])\n                        M[u][v] =\n                        M[v][u] = k-l;\n\n                    l = k;\n                    u = v;\n                }\n            }\n        }\n\n        for (int k=0; k<m; ++k)\n            for (int i=0; i<m; ++i)\n                if (i != k && M[i][k]!=INF)\n                for (int j=0; j<m; ++j)\n                    if (j != k)\n                    M[i][j] = min(M[i][j], M[i][k]+M[k][j]);\n\n        int mins = 1<<30, mi;\n        for (int i=0; i<m; ++i) {\n            int sum = 0;\n            for (int j=0; j<m; ++j)\n                sum += M[i][j];\n\n            if (sum < mins || (sum==mins && UID[i]<mi)) {\n                mins = sum;\n                mi = UID[i];\n            }\n        }\n        printf(\"Krochanska is in: %d\\n\", mi);\n    }\n\n    return 0;\n}\n\nint main(){\n    comp_func();\n    return 0;\n}\n", "entry_point": "comp_func"}
{"task_id": "cpp_3", "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<string> split_string(string);\n\nint queensAttack(int n, int k, int r_q, int c_q, vector<vector<int>> obstacles) {\n    int rowleft = c_q - 1;\n    int rowright = n - c_q;\n    int coldown = r_q - 1;\n    int colup = n - r_q;\n    int rightup = min(rowright, colup);\n    int rightdown = min(rowright, coldown);\n    int leftup = min(rowleft, colup);\n    int leftdown = min(rowleft, coldown);\n\n    int r, c;\n    for (auto o : obstacles) {\n        r = o[0]; c = o[1];\n        if (c == c_q) {\n            if (r < r_q) coldown = min(coldown, r_q - r - 1);\n            else colup = min(colup, r - r_q - 1);\n        }\n        else if (r == r_q) {\n            if (c < c_q) rowleft = min(rowleft, c_q - c - 1);\n            else rowright = min(rowright, c - c_q - 1);\n        }\n        else if (abs(r - r_q) == abs(c - c_q)) {\n            if (c > c_q) {\n                if (r > r_q) rightup = min(rightup, c - c_q - 1);\n                else rightdown = min(rightdown, c - c_q - 1);\n            }\n            else {\n                if (r > r_q) leftup = min(leftup, c_q - c - 1);\n                else leftdown = min(leftdown, c_q - c - 1);\n            }\n        }\n    }\n\n    return rowleft + rowright + coldown + colup + rightdown + rightup + leftdown + leftup;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string nk_temp;\n    getline(cin, nk_temp);\n\n    vector<string> nk = split_string(nk_temp);\n\n    int n = stoi(nk[0]);\n\n    int k = stoi(nk[1]);\n\n    string r_qC_q_temp;\n    getline(cin, r_qC_q_temp);\n\n    vector<string> r_qC_q = split_string(r_qC_q_temp);\n\n    int r_q = stoi(r_qC_q[0]);\n\n    int c_q = stoi(r_qC_q[1]);\n\n    vector<vector<int>> obstacles(k);\n    for (int i = 0; i < k; i++) {\n        obstacles[i].resize(2);\n\n        for (int j = 0; j < 2; j++) {\n            cin >> obstacles[i][j];\n        }\n\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n    }\n\n    int result = queensAttack(n, k, r_q, c_q, obstacles);\n\n    fout << result << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\n\nvector<string> split_string(string input_string) {\n    string::iterator new_end = unique(input_string.begin(), input_string.end(), [](const char& x, const char& y) {\n        return x == y and x == ' ';\n        });\n\n    input_string.erase(new_end, input_string.end());\n\n    while (input_string[input_string.length() - 1] == ' ') {\n        input_string.pop_back();\n    }\n\n    vector<string> splits;\n    char delimiter = ' ';\n\n    size_t i = 0;\n    size_t pos = input_string.find(delimiter);\n\n    while (pos != string::npos) {\n        splits.push_back(input_string.substr(i, pos - i));\n\n        i = pos + 1;\n        pos = input_string.find(delimiter, i);\n    }\n\n    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));\n\n    return splits;\n}\n", "entry_point": "split_string"}
{"task_id": "cpp_4", "code": "#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <map>\n#include <time.h>\n\nusing namespace std;\n\n#define INPUT_FILE\t\t\"input.txt\"\n#define OUTPUT_FILE\t\t\"output.txt\"\n\nint N;\nchar A[64][64], B[64][64];\nint Sol, S[1024], Flag[1024];\n\n\nvoid back(int sol)\n{\n\tint i, j;\n\n\tif (sol == N)\n\t{\n\t\tfor (i = 0; i < N; i++)\n\t\t\tstrcpy(B[i], A[S[i]]);\n\n\t\tint bsol = 1;\n\t\tfor (i = 0; i < N; i++)\n\t\t\tfor (j = i + 1; j < N; j++)\n\t\t\tif (B[i][j] == '1')\n\t\t\t{\n\t\t\t\tbsol = 0;\n\t\t\t\ti = j = 1000;\n\t\t\t};\n\n\t\tif (!bsol)\n\t\t\treturn;\n\n\t\tint sol = 0;\n\t\tfor (i = 0; i < N; i++)\n\t\t\tfor (j = i + 1; j < N; j++)\n\t\t\t\tif (S[i] > S[j])\n\t\t\t\t\tsol++;\n\n\t\tif (sol < Sol)\n\t\t\tSol = sol;\n\t}\n\telse\n\tfor (i = 0; i < N; i++)\n\t\tif (!Flag[i])\n\t\t{\n\t\t\tFlag[i] = 1;\n\t\t\tS[sol] = i;\n\n\t\t\tback(sol + 1);\n\t\t\tFlag[i] = 0;\n\t\t}\n}\n\nint main()\n{\n\tint i, ii, ntests;\n\tfreopen(INPUT_FILE, \"rt\", stdin);\n\tfreopen(OUTPUT_FILE, \"wt\", stdout);\n\n\tscanf(\"%d\", &ntests);\n\n\tfor (ii = 1; ii <= ntests; ii++)\n\t{\n\t\tscanf(\"%d\", &N);\n\t\tfor (i = 0; i < N; i++)\n\t\t\tscanf(\"%s\\n\", &A[i]);\n\n\t\tSol = 99999;\n\t\tback(0);\n\n\t\tprintf(\"Case #%d: %d\\n\", ii, Sol);\n\t}\n\tfclose(stdout);\n\tfclose(stdin);\n\n}\n\n", "entry_point": "back"}
{"task_id": "cpp_5", "code": "# include<stdlib.h>\n# include<iostream>\n# include<vector>\n# include<cstring>\n# include<algorithm>\n\nusing namespace std;\n\n\n\nint n, m;\nvector<string> predictions;\nvector<vector<int>> overlap; \n\n\n\nvoid KMP(int index) {\n    string p = predictions[index]; \n\n    \n    string s = p;\n    s.insert(s.end(), p.begin(), p.end()-1); \n\n    \n    int np = p.size(), ns = s.size();\n    int T[np + 1];\n    T[0] = -1;\n    int cnd = 0;\n    for (int i = 1; i <= np; i++) {\n        T[i] = cnd;\n        while (cnd >= 0 && p[cnd] != p[i])\n            cnd = T[cnd];\n        cnd++;\n    }\n\n    \n    cnd = 0; \n    for (int i = 0; i <= ns; i++) { \n        while (cnd >= 0 && p[cnd] != s[i]) \n            cnd = T[cnd]; \n        cnd++; \n        if (cnd == np) {\n            \n\n            \n            if ( (2*np - i - 1) >= (2 * np - n))\n                overlap[index].push_back(i - np + 1);\n\n            \n            cnd = T[cnd];\n        }\n    }\n}\n\nbool cmp (vector<int> a, vector<int> b) { \n    int i = a.size() - 1, j = b.size() - 1;\n    while (i && j) {\n        if (a[i] < b[j]) return true;\n        else if (a[i] > b[j]) return false;\n        i--;\n        j--;\n    }\n    if (j == 0) return false; \n    else return true;\n}\n\nvoid test() {\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < overlap[i].size(); j++) cout<< overlap[i][j]<< \" \";\n        cout<<endl;\n    }\n}\n\nint main(){\n    while(cin >> n >> m) {\n        \n        predictions.clear();\n        overlap = vector<vector<int>>(m);\n        string temp;\n        \n        \n        for (int i = 0; i < m; i++) {\n            cin >> temp;\n            predictions.push_back(temp);\n            overlap[i].push_back(i);\n            KMP(i);\n        }\n        test();\n        \n        stable_sort(overlap.begin(), overlap.end(), cmp);\n\n        for (int i = 0; i < m; i++) {\n            int index = overlap[i][0];\n            cout << predictions[index] << endl;\n        }\n    }\n    return 0;\n}\n", "entry_point": "KMP"}
{"task_id": "cpp_6", "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <unordered_set>\n#include <utility>\n#include <algorithm>\n#include <sstream>\n#include <string.h>\n#include <stdio.h>\n\nusing namespace std;\n\n#define uint unsigned int\n#define INF ((int)10e6)\n#define FIND(Q, q) (Q.find(q) != Q.end())\n#define foreach(Q, it) for(auto it = (Q).begin(); it != (Q).end(); ++it)\n\n#define UNDEFINED -1\n\nclass Vertice\n{\npublic:\n    int id, index, lowlink;\n\n    Vertice() : Vertice(0) {}\n    Vertice(int id) : id(id), index(UNDEFINED), lowlink(0) {}\n};\n\nclass Edge\n{\npublic:\n    int x, y;\n\n    Edge(int x, int y) : x(x), y(y) {}\n};\n\nclass Graph\n{\npublic:\n    vector< vector< Edge* > > adj;\n    vector< Vertice* > V;\n    int num_nodes;\n    static int index;\n    static stack< Vertice* > S;\n\n    Graph() {}\n\n    Graph(int size) : adj(size), num_nodes(size), V(size) {\n        for (int i = 0; i < size; ++i)\n            V[i] = new Vertice(i);\n    }\n\n    void Insert(int x, int y)\n    {\n        adj[x].push_back(new Edge(x, y));\n    }\n\n    bool Tartjan()\n    {\n        index = 0;\n\n        foreach(V, it)\n        {\n            Vertice &v = **it;\n\n            if (v.index == UNDEFINED)\n            {\n                vector< Vertice *> &component = *StrongConnect(&v);\n                bool result = component.size() == num_nodes;\n\n                delete &component;\n                return result;\n            }\n        }\n\n        return true;\n    }\n\n    \n    vector< Vertice* >* StrongConnect(Vertice* v)\n    {\n        vector< Vertice* > &component = *new vector< Vertice* >;\n        v->index = index;\n        v->lowlink = index;\n        index++;\n        S.push(v);\n\n        foreach(adj[v->id], it)\n        {\n            Vertice *w = V[(*it)->y];\n\n            if (w->index == UNDEFINED)\n            {\n                StrongConnect(w);\n                v->lowlink = min(v->lowlink, w->lowlink);\n            }\n            else\n            {\n                v->lowlink = min(v->lowlink, w->lowlink);\n            }\n        }\n\n        if (v->lowlink == v->index)\n        {\n            Vertice *w;\n            do\n            {\n                w = S.top(); S.pop();\n                component.push_back(w);\n            } while (!(w == v));\n        }\n\n        return &component;\n    }\n\n};\n\nint Graph::index = 0;\nstack< Vertice* > Graph::S;\n\nint main()\n{\n    int N, M;\n\n    while (scanf(\"%d %d\\n\", &N, &M) && N != 0)\n    {\n        Graph G(N);\n\n        for (int i = 0; i < M; ++i)\n        {\n            int V, W, P;\n            scanf(\"%d %d %d\\n\", &V, &W, &P); V--; W--;\n\n            if (P == 1)\n            {\n                G.Insert(V, W);\n            }\n            else\n            {\n                G.Insert(V, W);\n                G.Insert(W, V);\n            }\n        }\n\n        printf(\"%d\\n\", G.Tartjan() ? 1 : 0);\n    }\n}", "entry_point": "StrongConnect"}
{"task_id": "cpp_7", "code": "#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass PickTeam {\npublic:\n    \n    vector <string> pickPeople(int teamSize, vector <string> people) {\n        int n = (int)people.size();\n        int lim = 1 << n;\n        vector<string> names;\n        int a[20][20];\n        vector<string> sol(teamSize);\n        int best = -2000000000;\n\n        for (vector<string>::size_type i = 0; i < people.size(); ++i) {\n            istringstream is(people[i]);\n            string t;\n            is >> t;\n            names.push_back(t);\n            for (int j = 0; j < n; ++j) {\n                int x;\n                is >> x;\n                a[i][j] = x;\n            }\n        }\n        for (int i = 0; i < lim; ++i) {\n            int cnt = 0;\n            vector<int> team;\n            for (int k = 0; (1 << k) <= i; ++k)\n                if ((1 << k) & i) {\n                    ++cnt;\n                    team.push_back(k);\n                }\n            if (cnt == teamSize) {\n                int sum = 0;\n                for (vector<int>::size_type j = 0; j < team.size() - 1; ++j)\n                    for (vector<int>::size_type k = j + 1; k < team.size(); ++k)\n                        sum += a[team[j]][team[k]];\n                if (sum > best) {\n                    for (vector<int>::size_type j = 0; j < team.size(); ++j)\n                        sol[j] = names[team[j]];\n                    best = sum;\n                }\n            }\n        }\n        sort(sol.begin(), sol.end());\n        return sol;\n    }\n\npublic:\n    void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); }\nprivate:\n    template <typename T> string print_array(const vector<T>& V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n    void verify_case(int Case, const vector <string>& Expected, const vector <string>& Received) { cerr << \"Test Case #\" << Case << \"...\"; if (Expected == Received) cerr << \"PASSED\" << endl; else { cerr << \"FAILED\" << endl; cerr << \"\\tExpected: \" << print_array(Expected) << endl; cerr << \"\\tReceived: \" << print_array(Received) << endl; } }\n    void test_case_0() {\n        int Arg0 = 3; string Arr1[] = { \"ALICE 0 1 -1 3\",\n\"BOB 1 0 2 -4\",\n\"CAROL -1 2 0 2\",\n\"DAVID 3 -4 2 0\" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); string Arr2[] = { \"ALICE\",  \"CAROL\",  \"DAVID\" }; vector <string> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); verify_case(0, Arg2, pickPeople(Arg0, Arg1));\n    }\n    void test_case_1() {\n        int Arg0 = 2; string Arr1[] = { \"ALICE 0 1 -1 3\",\n\"BOB 1 0 2 -4\",\n\"CAROL -1 2 0 2\",\n\"DAVID 3 -4 2 0\" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); string Arr2[] = { \"ALICE\",  \"DAVID\" }; vector <string> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); verify_case(1, Arg2, pickPeople(Arg0, Arg1));\n    }\n    void test_case_2() { int Arg0 = 2; string Arr1[] = { \"A 0 -2 -2\",\"B -2 0 -1\",\"C -2 -1 0\" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); string Arr2[] = { \"B\",  \"C\" }; vector <string> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); verify_case(2, Arg2, pickPeople(Arg0, Arg1)); }\n\n};\n\n\nint main()\n{\n    PickTeam ___test;\n    ___test.run_test(-1);\n}\n\n", "entry_point": "pickPeople"}
{"task_id": "cpp_8", "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<cstdio>\n#define DEBUG\n\nconst int NUMBER_LEN_MAX=10;\nconst int NODE_NUM_MAX=80000;\nconst int NONE=-1;\n\nstruct Node{\n\tbool leaf;\n\tint children[10];\n};\n\nNode nodes[NODE_NUM_MAX];\nint nodeNum;\n\n\nbool recordNumber(int root, char* number) {\n\tif(nodes[root].leaf)\n\t\treturn false;\n\t\n\tif (*number == '\\0') {\n\t\tnodes[root].leaf=true;\n\t\tfor(int i=0;i<10;i++)\n\t\t\tif(nodes[root].children[i]!=NONE)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tint digit=*number-'0';\n\tif(nodes[root].children[digit]==NONE){\n\t\tnodes[nodeNum].leaf = false;\n\t\t\n\t\tfor (int i = 0;i < 10;i++)\n\t\t\tnodes[nodeNum].children[i]=NONE;\n\t\tnodes[root].children[digit]=nodeNum++;\n\n\t}\n\treturn recordNumber(nodes[root].children[digit],number+1);\n}\n\nint main(){\n\tint caseNum;\n\tscanf(\"%d\",&caseNum);\n\twhile(caseNum-->0){\n\t\tnodes[0].leaf = false;\n\t\t\n\t\tfor (int i = 0;i < 10;i++)\n\t\t\tnodes[0].children[i]=NONE;\n\t\tnodeNum=1;\n\n\t\tint numberNum;\n\t\tscanf(\"%d\",&numberNum);\n\t\tbool consistent = true;\n\t\t\n\t\twhile (numberNum-- > 0) {\n\t\t\tchar number[NUMBER_LEN_MAX+1];\n\t\t\tscanf(\"%s\",number);\n\t\t\tif(consistent)\n\t\t\t\tconsistent=recordNumber(0,number);\n\t\t}\n\t\tprintf(consistent?\"YES\\n\":\"NO\\n\");\n\t}\n\treturn 0;\n\n}", "entry_point": "recordNumber"}
{"task_id": "cpp_9", "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num() {\n\tT i = 0;char c;\n\twhile (!isdigit(c = getchar()) && c != '-');\n\tbool flag = c == '-';\n\tflag ? (c = getchar()) : 0;\n\twhile (i = i * 10 - '0' + c, isdigit(c = getchar()));\n\treturn flag ? -i : i;\n}\ntemplate<class T1, class T2>inline void apmin(T1& a, const T2& b) {\n\tif (b < a) {\n\t\ta = b;\n\t}\n}\ntemplate<class T1, class T2>inline void apmax(T1& a, const T2& b) {\n\tif (a < b) {\n\t\ta = b;\n\t}\n}\nconst int N = 200010, INF = 0x7f7f7f7f;\nnamespace T {\n\tconst int E = N << 1;\n\tint to[E], bro[E], head[N], e;\n\tinline void init(int n) {\n\t\tmemset(head + 1, -1, n << 2);\n\t\te = 0;\n\t}\n\tinline void ae(int u, int v) {\n\t\tto[e] = v, bro[e] = head[u], head[u] = e++;\n\t}\n\tinline void add(int u, int v) {\n\t\tae(u, v), ae(v, u);\n\t}\n\tint len, cnt;\n    bool vis[N];\n\n    \n    int dfs(int x, int f) {\n\t\tint mxdep = 0, mndep = INF;\n\t\tfor (int i = head[x], v;~i;i = bro[i]) {\n\t\t\tif ((v = to[i]) != f) {\n\t\t\t\tint t = dfs(v, x) + 1;\n\t\t\t\tif (vis[v]) apmin(mndep, t);\n\t\t\t\telse apmax(mxdep, t);\n\t\t\t}\n\t\t}\n\t\tif (mxdep == len) {\n\t\t\tcnt++, vis[x] = true;\n\t\t\treturn -len;\n\t\t}\n\t\tif (mndep <= 0) {\n\t\t\tvis[x] = mxdep + mndep <= 0;\n\t\t\treturn vis[x] ? mndep : mxdep;\n\t\t}\n\t\tvis[x] = false;\n\t\treturn mxdep;\n\t}\n}\ninline bool check(int m) {\n\tT::len = m, T::cnt = 0;\n\tT::dfs(1, 0);\n\tif (!T::vis[1]) {\n\t\tT::cnt++;\n\t}\n\treturn T::cnt <= 2;\n}\ninline int Main() {\n\tint n = ni;\n\tT::init(n);\n\tfor (int i = 1;i < n;i++) {\n\t\tT::add(ni, ni);\n\t}\n\tint l = 0, r = n - 1;\n\twhile (l < r) {\n\t\tint m = (l + r) >> 1;\n\t\tif (check(m)) {\n\t\t\tr = m;\n\t\t}\n\t\telse {\n\t\t\tl = m + 1;\n\t\t}\n\t}\n\treturn l;\n}\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"station.in\", \"r\", stdin);\n\tfreopen(\"station.out\", \"w\", stdout);\n#endif\n\tfor (int tot = ni;tot--;printf(\"%d\\n\", Main()));\n\treturn 0;\n}\n", "entry_point": "dfs"}
{"task_id": "cpp_10", "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxN=100001*50;\nconst int maxD=55;\nconst int maxM=maxN;\n\nclass Graph\n{\npublic:\n\tint ecnt,Hd[maxN],Nt[maxM],V[maxM];\n\tGraph()\n\t{\n\t\tecnt=-1;\n\t\tmemset(Hd,-1,sizeof(Hd));\n\t}\n\tvoid Add_Edge(int u,int v)\n\t{\n\t\tNt[++ecnt]=Hd[u];\n\t\tHd[u]=ecnt;\n\t\tV[ecnt]=v;\n\t\treturn;\n\t}\n};\n\nint n,m,D;\nint Id[101000][maxD];\nint dfncnt,dfn[maxN],low[maxN],Bcc[maxN],bcccnt,St[maxN],top,inq[maxN];\nGraph G1,G2;\nchar In[maxD];\nint Dp[maxN],Sz[maxN],Dg[maxN];\nqueue<int> Qu;\n\nvoid Add_Edge(int u,int v);\nvoid tarjan(int u);\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&D);\n\tfor (int i=1,idcnt=0; i<=n; i++) for (int j=0; j<D; j++) Id[i][j]=++idcnt;\n\tfor (int i=1; i<=m; i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tfor (int j=0; j<D; j++) G1.Add_Edge(Id[u][j],Id[v][(j+1)%D]);\n\t}\n\tfor (int i=1; i<=n*D; i++) if (!dfn[i]) tarjan(i);\n\n\t\n\n\tfor (int i=1; i<=n*D; i++) for (int j=G1.Hd[i]; j!=-1; j=G1.Nt[j]) if (Bcc[i]!=Bcc[G1.V[j]]) G2.Add_Edge(Bcc[G1.V[j]],Bcc[i]);\n\n\tfor (int i=1; i<=n; i++) {\n\t\tscanf(\"%s\",In);\n\t\tset<int> S;\n\t\tfor (int j=0; j<D; j++)\n\t\t\tif (In[j]=='1'&&S.count(Bcc[Id[i][j]])==0) {\n\t\t\t\t++Sz[Bcc[Id[i][j]]];\n\t\t\t\tS.insert(Bcc[Id[i][j]]);\n\t\t\t}\n\t}\n\n\tfor (int i=1; i<=bcccnt; i++) for (int j=G2.Hd[i]; j!=-1; j=G2.Nt[j]) ++Dg[G2.V[j]];\n\tfor (int i=1; i<=bcccnt; i++) if (!Dg[i]) Qu.push(i);\n\twhile (!Qu.empty()) {\n\t\tint u=Qu.front();\n\t\tQu.pop();\n\t\tDp[u]+=Sz[u];\n\t\tfor (int i=G2.Hd[u]; i!=-1; i=G2.Nt[i]) {\n\t\t\tDp[G2.V[i]]=max(Dp[G2.V[i]],Dp[u]);\n\t\t\tif ((--Dg[G2.V[i]])==0) Qu.push(G2.V[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Dp[Bcc[Id[1][0]]]);\n\treturn 0;\n}\n\n\nvoid tarjan(int u)\n{\n\tdfn[u]=low[u]=++dfncnt;\n\tSt[++top]=u;\n\tinq[u]=1;\n\tfor (int i=G1.Hd[u]; i!=-1; i=G1.Nt[i]) {\n\t\tint v=G1.V[i];\n\t\tif (!dfn[v]) {\n\t\t\ttarjan(v);\n\t\t\tlow[u]=min(low[u],low[v]);\n\t\t} else if (inq[v]) low[u]=min(low[u],dfn[v]);\n\t}\n\tif (dfn[u]==low[u]) {\n\t\t++bcccnt;\n\t\tint v;\n\t\tdo inq[v=St[top--]]=0,Bcc[v]=bcccnt;\n\t\twhile (u!=v);\n\t}\n\treturn;\n}\n", "entry_point": "tarjan"}
{"task_id": "cpp_11", "code": "#include <fstream>\n#include <iostream>\n#include <vector>\n#include <string.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int maxn = 12;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = { 0,-1, 0, 1};\n\nint t, n, m;\nchar a[maxn][maxn];\nint x[3], y[3], cnt;\nint lastx[3], lasty[3];\nint ans;\n\ninline bool inside(int xx, int yy) {\n\treturn xx >= 0 && xx < n && yy >= 0 && yy < n;\n}\n\nint ret;\n\n\ninline void back(int k) {\n\tcout << k << '\\n';\n\tfor(int i = 0 ; i < n ; ++ i)\n\t\tcout << a[i] << '\\n';\n\t\n\t++ ret;\n\tif(ret >= 10000)\n\t\treturn;\n\tbool ok = true;\n\tfor(int i = 0 ; i < cnt ; ++ i)\n\t\tif(a[x[i]][y[i]] != 'X')\n\t\t\tok = false;\n\tfor(int i = 0 ; i < 4 ; ++ i) {\n\t\tbool change = false;\n\t\tfor(int j = 0 ; j < 3 ; ++ j) {\n\t\t\tlastx[j] = x[j];\n\t\t\tlasty[j] = y[j];\n\t\t\tif(inside(x[j] + dx[i], y[j] + dy[i]))\n\t\t\t\tif((a[x[j] + dx[i]][y[j] + dy[i]] == '.' || a[x[j] + dx[i]][y[j] + dy[i]] == 'X') && a[x[j]][y[j]] != 'X') {\n\t\t\t\t\tchange = true;\n\t\t\t\t\tx[j] += dx[i];\n\t\t\t\t\ty[j] += dy[i];\n\t\t\t\t}\n\t\t\tswap(a[x[j]][y[j]], a[lastx[j]][lasty[j]]);\n\t\t}\n\t\tif(change)\n\t\t\tback(k + 1);\n\t\tfor(int j = 0 ; j < 3 ; ++ j) {\n\t\t\tx[j] = lastx[j];\n\t\t\ty[j] = lasty[j];\n\t\t\tswap(a[x[j]][y[j]], a[lastx[j]][lasty[j]]);\n\t\t}\n\t}\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"uri1057.in\", \"r\", stdin);\n\tfreopen(\"uri1057.out\", \"w\", stdout);\n\t#endif\n\tcin >> t;\n\twhile (t --) {\n\t\tcnt = 0;\n\t\tans = 0x3f3f3f3f;\n\t\tcin >> n;\n\t\tfor(int i = 0 ; i < n ; ++ i)\n\t\t\tcin >> a[i];\n\t\tfor(int i = 0 ; i < n ; ++ i)\n\t\t\tfor(int j = 0 ; j < n ; ++ j)\n\t\t\t\tif(isalpha(a[i][j]) && a[i][j] != 'X') {\n\t\t\t\t\tx[cnt] = i;\n\t\t\t\t\ty[cnt++] = j;\n\t\t\t\t}\n\t\tcout << cnt << '\\n';\n\t\tassert(cnt == 3);\n\t\tback(0);\n\t}\n}\n", "entry_point": "back"}
{"task_id": "cpp_12", "code": "#include <bits/stdc++.h>\n#define N 1000020\nusing namespace std;\n\nint t;\n\nint to[N<<1], nxt[N<<1], head[N], cnt;\nvoid insert(int x, int y) {\n  to[++ cnt] = y; nxt[cnt] = head[x]; head[x] = cnt;\n  to[++ cnt] = x; nxt[cnt] = head[y]; head[y] = cnt;\n}\n\nint fa[N], vis[N], dep[N], max_depth, max_depth_node;\nvoid dfs(int x) {\n  vis[x] = 1;\n  for (int i = head[x]; i; i = nxt[i]) {\n    if (!vis[to[i]]) {\n      fa[to[i]] = x;\n      dep[to[i]] = dep[x] + 1;\n      if (dep[to[i]] > max_depth) {\n        max_depth = dep[to[i]];\n        max_depth_node = to[i];\n      }\n      dfs(to[i]);\n    }\n  }\n}\n\nint d[N], a[N], b[N], ans;\n\n\n\nint comp_func() {\n  scanf(\"%d\", &t);\n  while (t --) {\n    int n, m, x, y;\n    scanf(\"%d%d\", &n, &m);\n    cnt = 0;\n    for (int i = 1; i <= n; ++ i) {\n      head[i] = 0;\n    }\n    for (int i = 1; i <= m; ++ i) {\n      scanf(\"%d%d\", &x, &y);\n      insert(x, y);\n    }\n    max_depth = 1;\n    max_depth_node = 1;\n    dep[1] = 1;\n    for (int i = 1; i <= n; ++ i) {\n      vis[i] = 0;\n    }\n    dfs(1);\n\n    if (max_depth >= ceil(n * 0.5)) {\n      puts(\"PATH\");\n      printf(\"%d\\n\", max_depth);\n      int s = max_depth_node;\n      while (s) {\n        printf(\"%d \", s);\n        s = fa[s];\n      }\n      puts(\"\");\n    } else {\n      for (int i = 1; i <= max_depth; ++ i) {\n        d[i] = 0;\n      }\n      ans = 0;\n      for (int i = 1; i <= n; ++ i) {\n        if (!d[dep[i]]) {\n          d[dep[i]] = i;\n        } else {\n          ++ ans;\n          a[ans] = d[dep[i]];\n          b[ans] = i;\n          d[dep[i]] = 0;\n        }\n      }\n      puts(\"PAIRING\");\n      printf(\"%d\\n\", ans);\n      for (int i = 1; i <= ans; ++ i) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n    return comp_func();\n}", "entry_point": "comp_func"}
{"task_id": "cpp_13", "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <unordered_map>\n#include <string>\n\nstruct unit {\n    std::string parent=\"\";\n    unsigned weight=0;long unsigned cumul_weight=0;\n    std::vector<std::string> childs={};\n};\n\n\nbool read_line(auto& input_file, auto& container, std::string& my_name) {\n    input_file>>my_name;\n    if (input_file.eof()) {\n        return false;\n    }\n\n    if(input_file.get()!=' '||input_file.get()!='('){\n        std::cerr<<\"Something went wrong :(\"<<my_name.length()<<std::endl;return false;\n    }\n\n    \n    input_file>>container[my_name].weight;\n    if(!container[my_name].weight||input_file.get()!=')'){\n        std::cerr<<\"Something went wrong :P\"<<std::endl;return false;\n    }\n    std::string temp_child;\n    switch(input_file.get()) {\n        case ' ':\n            if (input_file.get()!='-'||input_file.get()!='>'||input_file.get()!=' ') {\n                std::cerr<<\"Something went wrong :O\"<<std::endl;return false;\n            }\n            for(;;){\n                input_file>>temp_child;\n                bool last = temp_child.back()!=',';\n                if(!last)\n                    temp_child.pop_back();\n                container[my_name].childs.push_back(temp_child);\n                container[temp_child].parent = my_name;\n                if (last) {\n                    if (input_file.get()!='\\n'&&!input_file.eof()) {\n                        std::cerr<<\"Something went wrong D:\"<<temp_child<<std::endl;return false;\n                    }\n                    return true;\n                }\n            }\n            break;\n        case '\\n':\n            return true;\n    }\n    return false;\n}\n\nvoid calculate_weights(auto& container, std::string name) {\n    unsigned answer = 0, balance=0;\n    bool balanced = true;\n    for (auto i : container[name].childs) {\n        if (container[i].cumul_weight==0) {\n            calculate_weights(container,i);\n        }\n        std::cout<<i<<','<<container[i].weight<<','<<container[i].cumul_weight<<std::endl;\n        unsigned cur_weight = container[i].weight + container[i].cumul_weight;\n        if(!balance)\n            balance=cur_weight;\n        else if(balance!=cur_weight) {\n            std::cout<<\"ON \"<<name<<\": \"<<balance<<\" IS NOT EQUAL TO \"<<cur_weight<<std::endl;\n            balanced=false;\n        }\n        answer +=container[i].weight + container[i].cumul_weight;\n    }\n    if (!balanced) {\n        std::cout<<\"WEIGHTS FOR \"<<name<<\": \";\n        for (auto i :container[name].childs) {\n            std::cout<<i<<'='<<container[i].weight+container[i].cumul_weight<<'('<<container[i].weight<<')'<<' ';\n        }std::cout<<std::endl;\n    }\n    container[name].cumul_weight = answer;\n}\n\nint main(int argc, char** argv) {\n    if (argc < 2) {\n        std::cout << \"Usage: {program} {name of input file}\"<<std::endl;\n        return 0;\n    }\n    std::string filename = argv[1];\n    std::cout<<\"reading file \"<<filename<<std::endl;\n\n    std::ifstream input_file;\n    input_file.open(filename);\n    if (!input_file.good()) {\n        std::cout<<\"something wrong with \"<<filename<<std::endl;\n        return 0;\n    }\n    std::unordered_map<std::string,unit> my_units;\n    std::string my_name;\n    while(read_line(input_file, my_units, my_name));\n\n    while(my_units[my_name].parent !=\"\"){\n        my_name=my_units[my_name].parent;\n    }\n    std::cout<<\"The bottom program is \"<<my_name<<std::endl;\n\n    calculate_weights(my_units,my_name);\n    std::cout<<my_units[my_name].cumul_weight<<std::endl;\n\n    return 0;\n}\n", "entry_point": "read_line"}
{"task_id": "cpp_14", "code": "#include <bits/stdc++.h>\n\nint CountMaxDig(std::vector<int> &A)\n{\n    int largest = A.at(0);\n    int count = 0;\n\n    for (unsigned int i = 0; i < A.size(); i++)\n    {\n        if (largest < A.at(i))\n        {\n            largest = A.at(i);\n        }\n    }\n    while (largest != 0)\n    {\n        largest /= 10;\n        count += 1;\n    }\n    return count;\n}\n\n\nstd::vector<int> RadixSort(std::vector<int>& A)\n{\n    int power = 1; \n    int digit = CountMaxDig(A);\n\n    for (int i = 0; i < digit; i++) \n    {\n\n        std::vector<int> new_array(A.size()); \n        std::array<int, 10> count; \n        count.fill({});\n\n        for (unsigned int j = 0; j < A.size(); j++)\n        {\n            int num = (A.at(j) / power) % 10; \n            count.at(num)++;\n        }\n\n        for (int j = 1; j < 10; j++) \n        {\n            count.at(j) += count.at(j - 1);\n        }\n\n        for (int k = A.size() - 1; k >= 0; k--) \n        {\n            int num = (A.at(k) / power) % 10;\n            new_array.at(count.at(num) - 1) = A.at(k);\n            count.at(num)--;\n        }\n\n        for (unsigned int j = 0; j < A.size(); j++) \n            A.at(j) = new_array.at(j);\n\n        power *= 10; \n    }\n    return A;\n}\n\nint main()\n{\n    std::vector<int> v = {9, 5, 3, 1, 7, 2, 4, 6, 8, 500, 325};\n    std::cout << \"\\nPut the numbers: \";\n    std::vector<int> new_v = RadixSort(v);\n    std::cout << std::endl;\n\n    for (unsigned int i = 0; i < new_v.size(); i++)\n    {\n        std::cout << new_v.at(i) << \"\\t\";\n    }\n    \n    printf(\"\\n\");\n    return 0;\n\n}", "entry_point": "RadixSort"}
{"task_id": "cpp_15", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint graph[10][10];\n\nvoid createGraph(int i, int j, vector<int> &indegree)\n{\n    graph[i][j] = 1;\n\n    indegree[j]++;\n}\n\n\nvoid KhansAlgorithm(int v, vector<int>& indegree)\n{\n    vector<int> answer;\n    queue<int> q;\n    for (int i = 1; i <= v; i++)\n    {\n        if (indegree[i] == 0)\n            q.push(i);\n    }\n\n    while (!q.empty())\n    {\n        int current = q.front();\n        answer.push_back(current);\n        q.pop();\n\n        for (int i = 1; i <= v; i++)\n        {\n            if(graph[current][i] != 0)\n            {\n                indegree[i]--;\n                if(indegree[i] == 0)\n                    q.push(i);\n            }\n        }\n    }\n\n    for (int i = 0; i < v; i++)\n        cout << answer[i] << \"  \";\n}\n\nint main()\n{\n    int V, edge, i, j;\n\n    cout << \"\\nEnter the number of vertex : \";\n    cin >> V;\n\n    vector<int> indegree(V + 1, 0);\n\n    for (i = 1; i <= V; i++)\n        for (j = 1; j <= V; j++)\n            graph[i][j] = 0;\n\n    for (i = 1; i <= V; i++)\n    {\n        while (1)\n        {\n            cout << \"Enter the edges from \" << i << \" or press -1 : \";\n            cin >> edge;\n            if (edge == -1)\n                break;\n            createGraph(i, edge, indegree);\n        }\n    }\n\n    KhansAlgorithm(V, indegree);\n\n    return 0;\n}\n", "entry_point": "KhansAlgorithm"}
{"task_id": "cpp_16", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 6e5 + 10;\n\nint n, m, l, r, x, s[N];\nchar op[3];\n\nstruct PersistentTrie {\n\tint nxt[N * 27][2], cnt[N * 27], root[N], sz;\n\tvoid init() {\n\t\troot[0] = 0; \n\t\tnxt[0][0] = nxt[0][1] = cnt[0] = 0;\n\t\tsz = 1;\n\t}\n\tvoid insert(int x, int &y, int val) {\n\t\ty = sz++;\n\t\tmemcpy(nxt[y], nxt[x], sizeof(nxt[y]));\n\t\tcnt[y] = cnt[x] + 1;\n\t\tint p = y;\n\t\tfor(int i = 25; ~i; --i) {\n\t\t\tint c = (val >> i) & 1;\n\t\t\tnxt[p][c] = sz++;\n\t\t\tp = nxt[p][c]; x = nxt[x][c];\n\t\t\tmemcpy(nxt[p], nxt[x], sizeof(nxt[p]));\n\t\t\tcnt[p] = cnt[x] + 1;\n\t\t}\n    }\n\n    \n    int query(int l, int r, int x) {\n\t\tint p = root[l - 1], q = root[r];\n\t\tfor(int i = 25; ~i; --i) {\n\t\t\tint c = (x >> i) & 1;\n\t\t\tif(cnt[nxt[p][c ^ 1]] < cnt[nxt[q][c ^ 1]]) {\n\t\t\t\tx ^= (c ^ 1) << i;\n\t\t\t\tp = nxt[p][c ^ 1]; q = nxt[q][c ^ 1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx ^= c << i;\n\t\t\t\tp = nxt[p][c]; q = nxt[q][c];\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n}Trie;\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tn++;\n\tTrie.init();\n\tTrie.insert(Trie.root[0], Trie.root[1], 0);\n\tfor(int i = 2; i <= n; ++i) {\n\t\tscanf(\"%d\", &x);\n\t\ts[i] = s[i - 1] ^ x;\n\t\tTrie.insert(Trie.root[i - 1], Trie.root[i], s[i]);\n\t}\n\tfor(int i = 1; i <= m; ++i) {\n\t\tscanf(\"%s\", op);\n\t\tif(op[0] == 'A') {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tn++;\n\t\t\ts[n] = s[n - 1] ^ x;\n\t\t\tTrie.insert(Trie.root[n - 1], Trie.root[n], s[n]);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d%d%d\", &l, &r, &x);\n\t\t\tx ^= s[n];\n\t\t\tprintf(\"%d\\n\", Trie.query(l, r, x));\n\t\t}\n\t}\n\treturn 0;\n}", "entry_point": "query"}
{"task_id": "cpp_17", "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dsu {\n    int n;\n    vector<int> p;\n    vector<int> r;\n    \n    Dsu(int _n) { n = _n; p.resize(n); r.resize(n); init(); }\n    inline void init() {\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n            r[i] = 1;\n        }\n    }\n    inline int find(int x) {\n        return p[x] == x ? x: p[x] = find(p[x]);\n    }\n    inline bool join(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        if (r[x] < r[y]) swap(x, y);\n        p[y] = x; r[x] += r[y];\n        return true;\n    }\n    inline bool check(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        return r[find(x)];\n    }\n};\n\nint dp[70][1<<17];\nbool trk[70][1<<17];\n\n\nvoid solve() {\n    int n,m,a,b;\n    cin >> n >> m >> a >> b;\n    vector<vector<pair<int,int>>> g(n);\n    Dsu dsu(n);\n    for (int _ = 0; _ < m; _++) {\n        int x,y,z;\n        cin >> x >> y >> z;\n        x--;y--;\n        if (z == a) dsu.join(x,y);\n        g[x].emplace_back(y,z);\n        g[y].emplace_back(x,z);\n    }\n    vector<int> pos(n, -1); int cnt = 0;\n    vector<int> belong(n), bit(n);\n    for (int i = 0; i < n; i++) {\n        if (dsu.find(i) == i && dsu.size(i) > 3) pos[i] = cnt++;\n    }\n    for (int i = 0; i < n; i++) {\n        int x = dsu.find(i);\n        belong[i] = x;\n        x = pos[x];\n        bit[i] = x==-1 ? 0 : (1<<x);\n    }\n    auto node = [&](int i, int msk){\n        return i<<cnt | msk;\n    };\n    memset(dp, 0x3f, sizeof dp);\n    const int MSK = 1<<cnt; \n    using pi = pair<int,int>;\n    priority_queue<pi,vector<pi>,greater<pi>> pq;\n    dp[0][bit[0]] = 0; pq.emplace(0, node(0,bit[0]));\n    while (!pq.empty()) {\n        int dis, nd;\n        tie(dis, nd) = pq.top(); pq.pop();\n        int i = nd>>cnt, msk = nd%MSK;\n        if (trk[i][msk]) continue;\n        trk[i][msk] = true;\n        for (auto& _: g[i]) {\n            int j,w;\n            tie(j,w) = _;\n            \n            if (w == b && (belong[i]==belong[j] || (msk&bit[j]))) continue;\n            int nxt = msk | bit[j];\n            if (dp[j][nxt] > dp[i][msk] + w) {\n                dp[j][nxt] = dp[i][msk] + w;\n                pq.emplace(dp[j][nxt], node(j,nxt));\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        cout << *min_element(dp[i], dp[i]+MSK) << ' ';\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    return 0;\n}\n", "entry_point": "solve"}
{"task_id": "cpp_18", "code": "#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\nconst int maxm = 202;\nconst int maxf = 10000000;\n\nint n,m;\nint cap[maxm][maxm];\n\nint tot_flow=0;\nint vis[maxm],flow[maxm],pre[maxm];\n\n\nvoid get_max_flow()\n{\n\twhile(true)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(flow,0,sizeof(flow));\n\t\tflow[1]=maxf;\n\n\t\twhile(true)\n\t\t{\n\t\t\tint max_flow=0;\n\t\t\tint max_loc=0;\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t\tif(!vis[i] && flow[i]>max_flow)\n\t\t\t\t{\n\t\t\t\t\tmax_flow=flow[i];\n\t\t\t\t\tmax_loc=i;\n\t\t\t\t}\n\n\t\t\tif(max_loc==0)\n\t\t\t\tbreak;\n\n\t\t\tvis[max_loc]=true;\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t\tif(!vis[i])\n\t\t\t\t{\n\t\t\t\t\tint tmp=min(max_flow,cap[max_loc][i]);\n\t\t\t\t\tif(flow[i]<tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tflow[i]=tmp;\n\t\t\t\t\t\tpre[i]=max_loc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\tif(flow[m]==0) break;\n\n\t\ttot_flow+=flow[m];\n\n\t\tint i=m;\n\t\twhile(i!=1)\n\t\t{\n\t\t\tint p=pre[i];\n\t\t\tcap[p][i]-=flow[m];\n\t\t\tcap[i][p]+=flow[m];\n\t\t\ti=p;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfstream fin(\"ditch.in\",ios::in);\n\tfstream fout(\"ditch.out\",ios::out);\n\n\tfin>>n>>m;\n\n\tint s,e,c;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfin>>s>>e>>c;\n\t\tcap[s][e]+=c;\n\t}\n\n\tget_max_flow();\n\t\n\tfout<<tot_flow<<endl;\n\tfin.close();\n\tfout.close();\n\treturn 0;\n}", "entry_point": "get_max_flow"}
{"task_id": "cpp_19", "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <bits/stdc++.h>\n#include <vector>\n\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::vector;\n\nint n=5 ,m=6 ;\nint  top[] = {1, 2, -1, 2, 1, -1} , bottom[] = {2, -1, -1, 2, -1, 3};\nint left[] = {2, 3, -1, -1, -1} , right[] = {-1, -1, -1, 1, -1};\nchar rule[][6] = {{'L', 'R', 'L', 'R', 'T', 'T'},\n\t\t {'L', 'R', 'L', 'R', 'B', 'B'},\n\t\t {'T', 'T', 'T', 'T', 'L', 'R'},\n\t\t {'B', 'B', 'B', 'B', 'T', 'T'},\n\t\t {'L', 'R', 'L', 'R', 'B', 'B'}};\nvector< vector<int> > head;\nint move[][2] = {{ 1, 0}, {-1, 0} , {0, 1}, {0, -1}};\nbool visited[5][6];\nint ans[5][6];\nint count=0;\n\nvoid display(int mat[][6]){\n\tfor(int i=0 ;i<n ;i++){\n\t\tfor(int j=0 ; j<m ; j++){\n\t\t\tint k = mat[i][j];\n\t\t\tif(k == 1)\tcout << \"+ \";\n\t\t\telse if(k == 0)\tcout << \"- \";\n\t\t\telse\t\tcout << \"X \";\n\t\t}\n\t\tcout << endl ;\n\t}\n}\n\nbool chk(){\n\tint a[6], b[6];\n\tfor(int i=0 ; i<m ; i++)\n\t\ta[i] = 0, b[i] = 0;\n\n\tfor(int i=0 ;i< 5 ;i++){\n\t\tint p=0,q=0;\n                for(int j=0 ; j<m ; j++){\n\t\t\tif(ans[i][j] == 1)\n\t\t\t\tp += 1, a[j] += 1;\n\t\t\tif(ans[i][j] == 0)\n\t\t\t\tq += 1, b[j] += 1;\n\t\t}\n\t\tif((p != left[i] && left[i] != -1) || (q != right[i] && right[i] != -1))\n\t\t\treturn false;\n        }\n\tfor(int i=0 ; i<m ; i++)\n\t\tif((a[i] != top[i] && top[i] != -1) || (b[i] != bottom[i] &&  bottom[i] != -1))\n\t\t\treturn false;\n\n\treturn true;\n}\n\n\nbool place_magnet(int x, int y, int tt) {\n\tif(tt == count)\n                return chk();\n\n\tint tempo[2] = {0 , 0}, temp, ii,jj,r,c;\n\tint choice[]= {1, 0, -1};\n\n\tint xx = head[tt][0], yy = head[tt][1];\n\n\n\tfor(int xyz=0 ; xyz< 3 ; xyz++){\n\t\ttemp = choice[xyz];\n\t\tbool boo = false;\n\n\t\tfor(int i=0 ; i<4 ; i++){\n                \tr = x + move[i][0];\n                \tc = y + move[i][1];\n\t\t\t\n\t\t\tif(rule[r][c] == 'T')\n                       \t\tii = r+1 , jj = c;\n                \telse if(rule[r][c] == 'L')\n                                ii = r , jj = c+1;\n\t\t\tif(temp == -1)\n\t\t\t\tcontinue;\n                \tif((0<=r && r<n) && (0<=c && c<m) ){\n                        \tif((temp == ans[r][c]))\n\t\t\t\t\tboo = true;\n\t\t\t\t\t\n\t\t\t\tfor(int k=0 ; k<4 ; k++){\n\t\t\t\t\tint rr = ii + move[k][0];\n                        \t\tint cc = jj + move[k][1];\n\t\t\t\t\tif(visited)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif((0<=rr && rr<n) && (0<=cc && cc<m)){\n\t\t\t\t\t\tif((temp == ans[rr][cc]) && visited[rr][cc]){\n\t\t\t\t\t\t\tboo = true;\n                                        \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                \t}\n        \t}\n\t\tif(boo  && temp != -1)\n            continue;\n        \n        ans[x][y] = temp;\n        \tvisited[x][y] = true;\n        \tif(rule[x][y] == 'T'){\n\t\t\tans[x+1][y] = temp != -1 ? temp^1 : -1;\n                \tvisited[x+1][y] = true;\n                \tii = x+1 , jj = y;\n        \t}\n        \telse if(rule[x][y] == 'L'){\n     \t\t\tans[x][y+1] = temp != -1 ? temp^1 : -1;\n                \tvisited[x][y+1] = true;\n                \tii = x , jj = y+1;\n       \t\t}\n\t\tif(ii == x && jj == y)\n\t\t\tcontinue; \n        \tif( place_magnet(xx ,yy , 1+tt) )\n        \t\treturn true;\n\n       \t\tans[x][y] = -1;\n        \tvisited[x][y] = false;\n\n        \tans[ii][jj] = -1;\n        \tvisited[ii][jj] = false;\n\t}\n\treturn false;\n}\n\nint main(){\n\tvector<int> h;\n\tfor(int i=0 ; i<n ; i++){\n\t\tfor(int j = 0; j<m ;j++){\t\t\t\n\t\t\tif(rule[i][j] == 'T' || rule[i][j] == 'L'){\n\t\t\t\th.clear();\n\t\t\t\th.push_back(i);\n\t\t\t\th.push_back(j);\n\t\t\t\thead.push_back(h);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tvisited[i][j] = false;\n\t\t\tans[i][j] = -1;\n\t\t}\n\t}\n\tplace_magnet(0,0,1);\n\tdisplay(ans);\n}\n", "entry_point": "place_magnet"}
{"task_id": "cpp_20", "code": "\n#include <iostream>\n#include <fstream>\n#include <ctime>\n#include <list>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\nprivate:\n    \n    int V;\n    list<int>* adj;\n    bool DFS_findCycle(int s, int* visited, vector<int>* cycle);\n    int flag = 0;\n\npublic:\n    \n    Graph();\n    Graph(int v);\n    ~Graph();\n\n    void addEdge(int v, int w);\n    void matrixToList(int** adjMatrix, int vertexSize);\n    bool findCycle(int* cycle);\n};\n\nGraph::Graph() {\n    this->V = 0;\n    this->flag = 0;\n    this->adj = nullptr;\n}\n\nGraph::Graph(int v) {\n    this->V = v;\n    this->flag = 0;\n    \n    v ? adj = new list<int>[v] : this->adj = nullptr;\n}\n\nGraph::~Graph() {\n    adj->~list();\n}\n\nvoid Graph::addEdge(int v, int w) {\n    this->adj[v].push_back(w);\n}\n\nvoid Graph::matrixToList(int** adjMatrix, int vertexSize) {\n    if (!adjMatrix)\n        return;\n    if (!vertexSize)\n        return;\n    if (!adj) adj = new list<int>[vertexSize];\n\n    for (int i = 0; i < vertexSize; i++) {\n        for (int j = 0; j < vertexSize; j++) {\n            if (adjMatrix[i][j]) this->addEdge(i, j);\n        }\n    }\n    this->V = vertexSize;\n}\n\nbool Graph::DFS_findCycle(int s, int* visited, vector<int>* path) {\n    if (this->flag == 1) return true;\n    else {\n        visited[s] = 1;\n        path->push_back(s);\n        for (auto i = adj[s].begin(); i != adj[s].end(); i++) {\n            if (!visited[*i]) {\n                DFS_findCycle(*i, visited, path);\n            }\n            if (visited[*i] == 1 && *i != s && !this->flag) {\n                path->push_back(*i);\n                this->flag = 1; return true;\n            }\n            if (this->flag) return true;\n        }\n        visited[s] = 2;\n        path->pop_back();\n        return false;\n    }\n}\n\n\nbool Graph::findCycle(int* cycle) {\n    int* visited = new int[V];\n    vector<int> path;\n\n    for (int i = 0; i < V; i++) {\n        visited[i] = 0; cycle[i] = 0;\n    }\n\n    for (int j = 0; j < this->V; j++) {\n        if (!visited[j]) {\n            if (DFS_findCycle(j, visited, &path)) {\n\n                int i = path.size() - 2;\n                cycle[path.at(path.size() - 1)] = 1;\n\n                while (path.at(i) != path.at(path.size() - 1)) {\n                    cycle[path.at(i)] = 1;\n                    i--;\n                }\n                delete[] visited;\n                return true;\n            }\n        }\n    }\n\n    delete[] visited;\n    return false;\n}\n\nint main() {\n    srand(time(NULL));\n\n    fstream fs;\n    fs.open(\"train10.csv\", fstream::out | fstream::in | fstream::app);\n\n    if (!fs.is_open()) {\n        cerr << \"ERROR: File is not open...\" << endl;\n    }\n    fs << \"aa,ab,ac,ad,ae,af,ag,ah,ai,aj,\"\n        << \"ba,bb,bc,bd,be,bf,bg,bh,bi,bj,\"\n        << \"ca,cb,cc,cd,ce,cf,cg,ch,ci,cj,\"\n        << \"da,db,dc,dd,de,df,dg,dh,di,dj,\"\n        << \"ea,eb,ec,ed,ee,ef,eg,eh,ei,ej,\"\n        << \"fa,fb,fc,fd,fe,ff,fg,fh,fi,fj,\"\n        << \"ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,\"\n        << \"ha,hb,hc,hd,he,hf,hg,hh,hi,hj,\"\n        << \"ia,ib,ic,id,ie,if,ig,ih,ii,ij,\"\n        << \"ja,jb,jc,jd,je,jf,jg,jh,ji,jj,\"\n        << \"isCycle:\" << endl;\n\n    for (int k = 0; k < 1000000; k++) {\n        int size = 10;\n        Graph g(size);\n        int** matrix = new int* [size];\n        for (int i = 0; i < size; i++) {\n            matrix[i] = new int[size];\n            for (int j = 0; j < size; j++)\n                matrix[i][j] = 0;\n        }\n\n        if (k % 7 == 0) {\n            for (int i = 0; i < size; i++) {\n                for (int j = 0; j < size; j++)\n                    matrix[i][j] = rand() % 2;\n            }\n        }\n        else {\n            for (int i = 0; i < size; i++) {\n                int j = rand() % size, m = rand() % size;\n                matrix[j][m] = 1;\n            }\n        }\n\n        g.matrixToList(matrix, size);\n        int* cycle = new int[size];\n        bool isCycle = g.findCycle(cycle);\n\n        for (int i = 0; i < size; i++)\n            for (int j = 0; j < size; j++)\n                fs << matrix[i][j] << \",\";\n        \n        fs << isCycle << endl;\n\n        for (int i = 0; i < size; i++)\n            delete[] matrix[i];\n        delete[] matrix;\n    }\n    return 0;\n}", "entry_point": "findCycle"}
