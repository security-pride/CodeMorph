{"task_id": "go_1", "code": "package main\n\nimport (\n\t\"math/rand\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar r rand.Source = rand.New(rand.NewSource(time.Now().Unix()))\nvar n, s, e, w int = 1, 2, 4, 8\nvar dx = map[int]int{e: 1, w: -1, n: 0, s: 0}\nvar dy = map[int]int{e: 0, w: 0, n: -1, s: 1}\nvar opposite = map[int]int{e: w, w: e, n: s, s: n}\n\n\nfunc ascii(matrix [][]int) {\n\n\tprint(\" \")\n\tfor z := 0; z < len(matrix[0])*2-1; z++ {\n\t\tprint(\"_\")\n\t}\n\n\tprintln()\n\tfor i := 0; i < len(matrix[0]); i++ {\n\t\tprint(\"|\")\n\t\tfor j := 0; j < len(matrix); j++ {\n\t\t\tif matrix[i][j]&s != 0 {\n\t\t\t\tprint(\" \")\n\t\t\t} else {\n\t\t\t\tprint(\"_\")\n\t\t\t}\n\t\t\tif matrix[i][j]&e != 0 {\n\t\t\t\tif (matrix[i][j]|matrix[i][j+1])&s != 0 {\n\t\t\t\t\tprint(\" \")\n\t\t\t\t} else {\n\t\t\t\t\tprint(\"_\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint(\"|\")\n\t\t\t}\n\t\t}\n\t\tprintln()\n\t}\n}\n\nfunc backtracer(cx, cy int, m [][]int) {\n\n\tdir := []int{n, s, e, w}\n\trand.Shuffle(len(dir), func(i, j int) { dir[i], dir[j] = dir[j], dir[i] })\n\n\tfor _, direction := range dir {\n\t\tnx := cx + dx[direction]\n\t\tny := cy + dy[direction]\n\n\t\tif (ny >= 0 && ny < len(m)) && (nx >= 0 && nx < len(m[0])) && (m[ny][nx] == 0) {\n\t\t\tm[cy][cx] |= direction\n\t\t\tm[ny][nx] |= opposite[direction]\n\t\t\tbacktracer(nx, ny, m)\n\t\t}\n\n\t}\n}\n\nfunc main() {\n\tif len(os.Args) < 3 {\n\t\tprintln(\"Parameters not given\")\n\t\tos.Exit(0)\n\t}\n\tx, _ := strconv.Atoi(os.Args[1])\n\ty, _ := strconv.Atoi(os.Args[2])\n\n\trand.Seed(time.Now().UTC().UnixNano())\n\tmatrix := make([][]int, y)\n\tfor i := 0; i < y; i++ {\n\t\tmatrix[i] = make([]int, x)\n\t}\n\n\tbacktracer(0, 0, matrix)\n\n\tascii(matrix)\n\tprintln()\n\n}\n", "entry_point": "ascii"}
{"task_id": "go_2", "code": "package day14\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n)\n\ntype Pair [2]string\n\n\nfunc parseFile() (map[Pair]int, map[Pair]string, string) {\n\t_, fileName, _, _ := runtime.Caller(0)\n\tprefixPath := filepath.Dir(fileName)\n\tfile, err := os.Open(prefixPath + \"/input.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\tscanner := bufio.NewScanner(file)\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"reading standard input:\", err)\n\t}\n\tpairs := make(map[Pair]int)\n\tinsertionMap := make(map[Pair]string)\n\trow := 0\n\tlastChar := \"\"\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t} else if row == 0 {\n\t\t\tchars := strings.Split(line, \"\")\n\t\t\tlastChar = chars[len(chars)-1]\n\t\t\tfor i := 0; i < len(chars)-1; i++ {\n\t\t\t\tpairs[Pair{chars[i], chars[i+1]}] += 1\n\t\t\t}\n\t\t\trow += 1\n\t\t} else {\n\t\t\tparts := strings.Fields(line)\n\t\t\tchars := strings.Split(parts[0], \"\")\n\t\t\tinsertionMap[Pair{chars[0], chars[1]}] = parts[2]\n\t\t}\n\t}\n\treturn pairs, insertionMap, lastChar\n}\n\nfunc Insert(pairs map[Pair]int, insertionMap map[Pair]string) map[Pair]int {\n\tnewPairs := make(map[Pair]int)\n\tfor pair, count := range pairs {\n\t\tchar, exists := insertionMap[pair]\n\t\tif exists {\n\t\t\tnewPairs[pair] -= count\n\t\t\tnewPairs[Pair{pair[0], char}] += count\n\t\t\tnewPairs[Pair{char, pair[1]}] += count\n\t\t}\n\t}\n\tfor pair, count := range newPairs {\n\t\tpairs[pair] += count\n\t}\n\treturn pairs\n}\n\nfunc MinMax(pairs map[Pair]int, lastChar string) (string, int, string, int) {\n\tchars := make(map[string]int)\n\tfor pair, count := range pairs {\n\t\tchars[pair[0]] += count\n\t}\n\tchars[lastChar] += 1\n\tminChar, maxChar := \"\", \"\"\n\tminCount, maxCount := math.MaxInt, 0\n\tfor char, count := range chars {\n\t\tif count < minCount {\n\t\t\tminCount = count\n\t\t\tminChar = char\n\t\t\t\n\t\t}\n\t\tif count > maxCount {\n\t\t\tmaxCount = count\n\t\t\tmaxChar = char\n\t\t\t\n\t\t}\n\t}\n\n\treturn minChar, minCount, maxChar, maxCount\n}\n\nfunc Day14() {\n\tpairs, insertionMap, lastChar := parseFile()\n\tfmt.Println(pairs)\n\tfor step := 0; step < 40; step++ {\n\t\tfmt.Println(\"-----\")\n\t\tpairs = Insert(pairs, insertionMap)\n\t\tfmt.Println(pairs)\n\t\tminChar, minCount, maxChar, maxCount := MinMax(pairs, lastChar)\n\t\tfmt.Println(minChar, minCount, maxChar, maxCount)\n\t\tfmt.Println(maxCount - minCount)\n\t}\n}\n", "entry_point": "parseFile"}
{"task_id": "go_3", "code": "package offer0029\n\nimport \"math\"\n\ntype pos struct{ x, y int }\n\n\nfunc spiralOrder(matrix [][]int) []int {\n\tif len(matrix) == 0 {\n\t\treturn []int{}\n\t}\n\tdirects := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n\tcurDir := 0\n\tstart := pos{0, 0}\n\tans := []int{}\n\tq := []pos{start}\n\tfor len(q) != 0 {\n\t\tcurx, cury := q[0].x, q[0].y\n\t\tq = q[1:]\n\t\tans = append(ans, matrix[curx][cury])\n\t\tmatrix[curx][cury] = math.MinInt32\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tnewx, newy := curx+directs[curDir][0], cury+directs[curDir][1]\n\t\t\tif newx < 0 || newy < 0 || newx >= len(matrix) || newy >= len(matrix[0]) || matrix[newx][newy] == math.MinInt32 {\n\t\t\t\tcurDir = (curDir + 1) % 4\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tq = append(q, pos{newx, newy})\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n", "entry_point": "spiralOrder"}
{"task_id": "go_4", "code": "package tools\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/rsa\"\n\t\"crypto/sha1\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc Hash(data []byte) string {\n\ts := sha1.Sum(data)\n\tm := md5.Sum(data)\n\treturn fmt.Sprintf(\"%x%x\", s[:8], m[:8])\n}\n\n\nfunc SimpleMatch(pattern, s string) bool {\n\ti, j, star, match := 0, 0, -1, 0\n\tfor i < len(s) {\n\t\tif j < len(pattern) && (s[i] == pattern[j] || pattern[j] == '?') {\n\t\t\ti++\n\t\t\tj++\n\t\t} else if j < len(pattern) && pattern[j] == '*' {\n\t\t\tmatch, star = i, j\n\t\t\tj++\n\t\t} else if star != -1 {\n\t\t\tj = star + 1\n\t\t\tmatch++\n\t\t\ti = match\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor ; j < len(pattern); j++ {\n\t\tif pattern[j] != '*' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc MapMatch(pattern map[string]string, data map[string]string) int {\n\tif len(pattern) > len(data) { \n\t\treturn 0\n\t}\n\n\tscore := 1\n\tfor key, pattern := range pattern {\n\t\tvalue, ok := data[key]\n\t\tif !ok {\n\t\t\treturn 0\n\t\t}\n\t\tif i := SimpleMatchScore(pattern, value); i > 0 {\n\t\t\tscore += i\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\treturn score\n}\n\nfunc SimpleMatchScore(pattern, s string) int {\n\tif pattern == s { \n\t\treturn 2\n\t}\n\tif SimpleMatch(pattern, s) {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc RSAPublickDecryptEasy(key, data []byte) ([]byte, error) {\n\tblock, _ := pem.Decode(key)\n\tif block == nil || block.Type != \"PUBLIC KEY\" {\n\t\treturn nil, errors.New(\"failed to decode PEM block containing public key\")\n\t}\n\tpub, err := x509.ParsePKIXPublicKey(block.Bytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse public key: %s\", err.Error())\n\t}\n\treturn RSAPublickDecrypt(pub.(*rsa.PublicKey), data), nil\n}\n\nfunc RSAPublickDecrypt(pubKey *rsa.PublicKey, data []byte) []byte {\n\tc := new(big.Int)\n\tm := new(big.Int)\n\tm.SetBytes(data)\n\te := big.NewInt(int64(pubKey.E))\n\tc.Exp(m, e, pubKey.N)\n\tout := c.Bytes()\n\tskip := 0\n\tfor i := 2; i < len(out); i++ {\n\t\tif i+1 >= len(out) {\n\t\t\tbreak\n\t\t}\n\t\tif out[i] == 0xff && out[i+1] == 0 {\n\t\t\tskip = i + 2\n\t\t\tbreak\n\t\t}\n\t}\n\treturn out[skip:]\n}\n", "entry_point": "SimpleMatch"}
{"task_id": "go_5", "code": "\n\n\n\npackage src\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype muxContextKey string\n\ntype route struct {\n\tmethod string\n\tsegments []string\n\thandler http.Handler\n\tprefix bool\n}\n\ntype Router struct {\n\troutes []*route\n\tNotFound http.Handler\n}\n\nfunc NewRouter() *Router {\n\treturn &Router{\n\t\tNotFound: http.NotFoundHandler(),\n\t}\n}\n\n\n\nfunc (r *Router) pathSegments(pattern string) []string {\n\treturn strings.Split(strings.Trim(pattern, \"/\"), \"/\")\n}\n\nfunc (r *Router) Handle(method, pattern string, handler http.Handler) {\n\troute := &route{\n\t\tmethod: strings.ToLower(method),\n\t\tsegments: r.pathSegments(pattern),\n\t\thandler: handler,\n\t\tprefix: strings.HasPrefix(pattern, \"/\") || strings.HasSuffix(pattern, \"...\"),\n\t}\n\tr.routes = append(r.routes, route)\n}\n\nfunc (r *Router) HandleFunc(method, pattern string, fn http.HandlerFunc)  {\n\tr.Handle(method, pattern, fn)\n}\n\nfunc (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tmethod := strings.ToLower(req.Method)\n\tsegments := r.pathSegments(req.URL.Path)\n\tfor _, route := range r.routes {\n\t\tif route.method != method && route.method != \"*\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif ctx, ok := route.match(req.Context(), r, segments); ok {\n\t\t\troute.handler.ServeHTTP(w, req.WithContext(ctx))\n\t\t\treturn\n\t\t}\n\t}\n\tr.NotFound.ServeHTTP(w, req)\n}\n\nfunc Param(ctx context.Context, param string) string {\n\tvalue, ok :=  ctx.Value(muxContextKey(param)).(string)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn value\n}\n\n\nfunc (r *route) match(ctx context.Context, router *Router, segments []string) (context.Context, bool) {\n\tif len(segments) > len(r.segments) && !r.prefix {\n\t\treturn nil, false\n\t}\n\n\tfor i, seg := range r.segments {\n\t\tif i > len(segments) -1{\n\t\t\treturn nil, false\n\t\t}\n\t\tisParam := false\n\t\tif strings.HasPrefix(seg, \":\") {\n\t\t\tisParam = true\n\t\t\tseg = strings.TrimPrefix(seg, \":\")\n\t\t}\n\t\tif !isParam {\n\t\t\tif strings.HasSuffix(seg, \"...\") {\n\t\t\t\tif strings.HasPrefix(segments[i], seg[:len(seg)-3]) {\n\t\t\t\t\treturn ctx, true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif seg != segments[i] {\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t}\n\n\t\tif isParam {\n\t\t\tctx = context.WithValue(ctx, muxContextKey(seg), segments[i])\n\t\t}\n\t}\n\treturn ctx, true\n}", "entry_point": "match"}
{"task_id": "go_6", "code": "package p1239\n\n\nfunc maxLength(arr []string) int {\n\tflags := make([]int, len(arr))\n\tvar n int\n\n\tfor i := 0; i < len(arr); i++ {\n\t\tvar flag int\n\t\tm := len(arr[i])\n\n\t\tfor j := 0; j < m; j++ {\n\t\t\tx := int(arr[i][j] - 'a')\n\t\t\tif flag&(1<<uint(x)) > 0 {\n\t\t\t\tflag = 0\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tflag |= 1 << uint(x)\n\t\t}\n\t\tif flag == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tarr[n] = arr[i]\n\t\tflags[n] = flag\n\t\tn++\n\t}\n\tN := 1 << uint(n)\n\n\tvar best int\n\n\tfor state := 1; state < N; state++ {\n\t\tvar tmp int\n\t\tvar totalLen int\n\t\tvar duplicate bool\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif state&(1<<uint(i)) > 0 {\n\t\t\t\tflag := flags[i]\n\n\t\t\t\tif tmp&flag > 0 {\n\t\t\t\t\tduplicate = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttmp |= flag\n\t\t\t\ttotalLen += len(arr[i])\n\t\t\t}\n\t\t}\n\t\tif duplicate {\n\t\t\tcontinue\n\t\t}\n\t\tif totalLen > best {\n\t\t\tbest = totalLen\n\t\t}\n\t}\n\treturn best\n}\n", "entry_point": "maxLength"}
{"task_id": "go_7", "code": "\npackage radixsort\n\n\nfunc RadixSort(slice []int) {\n\n  if len(slice) == 0 {\n    return\n  }\n\n  length := len(slice)\n  higher := slice[0]\n  exp := 1\n  var temp []int\n\n  for index := 0; index < length; index++ {\n    temp = append(temp, 0)\n    if slice[index] > higher {\n      higher = slice[index]\n    }\n  }\n\n  for higher/exp > 0 {\n    var bucket [10]int\n\n    for index := 0; index < length; index++ {\n      bucket[(slice[index]/exp) % 10] = bucket[(slice[index]/exp) % 10] + 1\n    }\n\n    for index := 1; index < 10; index++ {\n      bucket[index] = bucket[index] + bucket[index-1]\n    }\n\n    for index := length-1; index >= 0; index-- {\n      bucket[(slice[index] / exp) % 10] = bucket[(slice[index] / exp) % 10] - 1\n      temp[bucket[(slice[index] / exp) % 10]] = slice[index]\n    }\n\n    for index := 0; index < length; index++ {\n      slice[index] = temp[index]\n    }\n\n    exp = exp * 10\n  }\n}\n", "entry_point": "RadixSort"}
{"task_id": "go_8", "code": "package traverser\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nconst (\n\topNoop = iota\n\topSet\n\topUnset\n\topSkip\n\topSplice\n)\n\ntype Traverser struct {\n\tMap    func(keys []string, key string, data reflect.Value)\n\tNode   func(keys []string, data reflect.Value) (Op, error)\n\tAccept func(keys []string, data reflect.Value) (Op, error)\n}\n\ntype Op struct {\n\top  int\n\tval reflect.Value\n}\nfunc (gt *Traverser) Traverse(original reflect.Value) (reflect.Value, error) {\n\tif !original.IsValid() {\n\t\treturn reflect.Value{}, nil\n\t}\n\n\tcopy := reflect.New(original.Type()).Elem()\n\t_, err := gt.traverse(copy, original, []string{})\n\treturn copy, err\n}\n\n\nfunc (gt *Traverser) traverse(copy, original reflect.Value, keys []string) (Op, error) {\n\tif gt.Accept != nil && len(keys) > 0 {\n\t\top, _ := gt.Accept(keys, copy)\n\t\tif op.op == opSkip {\n\t\t\treturn Noop()\n\t\t}\n\t}\n\n\tswitch original.Kind() {\n\tcase reflect.Ptr:\n\t\toriginalValue := original.Elem()\n\t\tif !originalValue.IsValid() {\n\t\t\treturn Noop()\n\t\t}\n\t\tcopy.Set(reflect.New(originalValue.Type()))\n\t\treturn gt.traverse(copy.Elem(), originalValue, keys)\n\n\tcase reflect.Interface:\n\t\toriginalValue := original.Elem()\n\t\tif !originalValue.IsValid() {\n\t\t\treturn Noop()\n\t\t}\n\t\tcopyValue := reflect.New(originalValue.Type()).Elem()\n\t\top, err := gt.traverse(copyValue, originalValue, keys)\n\t\tcopy.Set(copyValue)\n\t\treturn op, err\n\n\tcase reflect.Struct:\n\t\tfor i := 0; i < original.NumField(); i++ {\n\t\t\tif original.Field(i).CanSet() {\n\t\t\t\top, err := gt.traverse(copy.Field(i), original.Field(i), append(keys, original.Type().Field(i).Name))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn op, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif gt.Node != nil {\n\t\t\treturn gt.Node(keys, original)\n\t\t}\n\n\tcase reflect.Slice:\n\t\tcopy.Set(reflect.MakeSlice(original.Type(), original.Len(), original.Cap()))\n\n\t\tci := -1\n\t\tfor i := 0; i < original.Len(); i++ {\n\t\t\tci++\n\t\t\tcopyValue := copy.Interface().([]interface{})\n\t\t\top, err := gt.traverse(copy.Index(ci), original.Index(i), append(keys, fmt.Sprintf(\"%d\", i)))\n\t\t\tif err != nil {\n\t\t\t\treturn op, err\n\t\t\t}\n\n\t\t\tif op.op == opSet {\n\t\t\t\tcopyValue[i] = op.val.Interface()\n\t\t\t\tcopy.Set(reflect.ValueOf(copyValue))\n\t\t\t} else if op.op == opUnset {\n\t\t\t\tcopy.Set(reflect.ValueOf(append(copyValue[:ci], copyValue[ci+1:]...)))\n\t\t\t\tci--\n\t\t\t} else if op.op == opSplice {\n\t\t\t\tsplice, ok := op.val.Interface().([]interface{})\n\t\t\t\tif !ok {\n\t\t\t\t\treturn ErrorNoop(fmt.Errorf(\"only slices can be spliced\"))\n\t\t\t\t}\n\t\t\t\tcopyValue = append(copyValue[:ci], append(splice, copyValue[ci+1:]...)...)\n\t\t\t\tcopy.Set(reflect.ValueOf(copyValue))\n\t\t\t\tci += len(splice) - 1\n\t\t\t}\n\t\t}\n\n\t\tif gt.Node != nil {\n\t\t\treturn gt.Node(keys, original)\n\t\t}\n\n\tcase reflect.Map:\n\t\tcopy.Set(reflect.MakeMap(original.Type()))\n\t\tfor _, key := range original.MapKeys() {\n\t\t\toriginalValue := original.MapIndex(key)\n\t\t\tcopyValue := reflect.New(originalValue.Type()).Elem()\n\n\t\t\tkeyString := fmt.Sprintf(\"%v\", key)\n\t\t\tif gt.Map != nil {\n\t\t\t\tgt.Map(keys, keyString, originalValue)\n\t\t\t}\n\n\t\t\top, err := gt.traverse(copyValue, originalValue, append(keys, keyString))\n\t\t\tcopy.SetMapIndex(key, copyValue)\n\n\t\t\tif err != nil {\n\t\t\t\treturn op, err\n\t\t\t}\n\n\t\t\tif op.op == opSet || op.op == opUnset {\n\t\t\t\tcopy.SetMapIndex(key, op.val)\n\t\t\t}\n\t\t}\n\n\t\tif gt.Node != nil {\n\t\t\treturn gt.Node(keys, original)\n\t\t}\n\n\tdefault:\n\t\tcopy.Set(original)\n\t\tif gt.Node != nil {\n\t\t\treturn gt.Node(keys, original)\n\t\t}\n\t}\n\n\treturn Noop()\n}\n\n\nfunc Set(v reflect.Value) (Op, error) {\n\treturn Op{opSet, v}, nil\n}\n\n\nfunc Noop() (Op, error) {\n\treturn Op{opNoop, reflect.Value{}}, nil\n}\n\n\nfunc Unset() (Op, error) {\n\treturn Op{opUnset, reflect.Value{}}, nil\n}\n\nfunc Splice(v reflect.Value) (Op, error) {\n\treturn Op{opSplice, v}, nil\n}\n\n\nfunc ErrorSet(err error, v reflect.Value) (Op, error) {\n\treturn Op{opSet, v}, err\n}\n\n\nfunc ErrorUnset(err error) (Op, error) {\n\treturn Op{opUnset, reflect.Value{}}, err\n}\n\n\nfunc ErrorNoop(err error) (Op, error) {\n\treturn Op{opNoop, reflect.Value{}}, err\n}\n\n\nfunc Skip() (Op, error) {\n\treturn Op{opSkip, reflect.Value{}}, nil\n}\n", "entry_point": "traverse"}
{"task_id": "go_9", "code": "package io\n\nimport (\n\t\"io\"\n\t\"math/rand\"\n\t\"encoding/binary\"\n)\n\ntype RingedWriter struct {\n\tring   *[]byte\n\tcursor *int\n}\n\n\nfunc (rw *RingedWriter) Write(p []byte) (n int, err error) {\n\tnewData := fillBytes(len(p), func() []byte {return p})\n\t*rw.ring = make([]byte, 0, len(*newData))\n\t*rw.ring = append(*rw.ring, (*newData)[:]...)\n\trw.resetNowOn()\n\n\treturn len(p), nil\n}\n\nfunc (rw *RingedWriter) resetNowOn() {\n\t*rw.cursor = 0\n}\n\nfunc fillBytes(ringSize int, getData func() []byte) *[]byte {\n\tring := make([]byte, ringSize)\n\tcurLength := 0\n\tfor curLength < ringSize {\n\t\tdata := getData()\n\t\tif len(data) == 0 {\n\t\t\tfor i := curLength; i < ringSize; i++ {\n\t\t\t\tring[i] = 0\n\t\t\t}\n\t\t\tcurLength = ringSize\n\t\t}\n\t\tfor i := curLength; i < ringSize && i-curLength < len(data); i++ {\n\t\t\tring[i] = data[i-curLength]\n\t\t}\n\t\tcurLength += len(data)\n\t}\n\n\treturn &ring\n}\n\n\nfunc NewRingedWriter(ringSize int, source io.Reader) (io.Writer, *[]byte, *int) {\n\tvar getData func() []byte\n\tif source != nil {\n\t\t\n\t\tgetData = func() []byte {\n\t\t\tdata := make([]byte, ringSize)\n\t\t\tn, err := source.Read(data)\n\t\t\tif err != nil {\n\t\t\t\tfor i := range data {\n\t\t\t\t\tdata[i] = 0\n\t\t\t\t}\n\t\t\t\treturn data\n\t\t\t}\n\t\t\tif n < ringSize {\n\t\t\t\tfor i := n; i < ringSize; i++ {\n\t\t\t\t\tdata[i] = 0\n\t\t\t\t}\n\t\t\t\treturn data\n\t\t\t}\n\t\t\treturn data[0:ringSize]\n\t\t}\n\t} else {\n\t\t\n\t\tgetData = func() []byte {\n\t\t\tdata := make([]byte, ringSize)\n\t\t\tfor i := 0; i < ringSize; {\n\t\t\t\tbs := make([]byte, 8)\n\t\t\t\tbinary.LittleEndian.PutUint64(bs, rand.Uint64())\n\t\t\t\tfor j := 0; j < len(bs) && i + j < len(data); j++ {\n\t\t\t\t\tdata[i + j] = bs[j]\n\t\t\t\t}\n\t\t\t\ti += len(bs)\n\t\t\t}\n\t\t\treturn data\n\t\t}\n\t}\n\n\trw := RingedWriter{fillBytes(ringSize, getData), new(int)}\n\treturn &rw, rw.ring, rw.cursor\n}\n", "entry_point": "NewRingedWriter"}
{"task_id": "go_10", "code": "\n\n\n\n\n\n\npackage moonrise\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype month struct {\n\trise   [31]time.Time\n\tset    [31]time.Time\n\triseok [31]bool\n\tsetok  [31]bool\n}\n\ntype year struct {\n\tyear   int\n\tmonths [12]month\n\tloc    *time.Location\n}\n\ntype Db struct {\n\tyears []*year\n}\n\nconst noyear = 10000\n\nfunc errFmt(what string) error {\n\treturn fmt.Errorf(\"problem with the report format: %v\", what)\n}\n\nfunc (db *Db) Load(report string) error {\n\ty, err := read(report)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdb.years = append(db.years, y)\n\treturn nil\n}\n\nfunc (db *Db) Moonrise(tm time.Time) (time.Time, bool) {\n\ty2 := tm.Year()\n\tfor _, y := range db.years {\n\t\tif y.year == y2 {\n\t\t\treturn y.Moonrise(tm)\n\t\t}\n\t}\n\treturn zero, false\n}\n\n\nfunc read(report string) (y *year, err error) {\n\ty = &year{}\n\n\tday := 0\n\ty.year = noyear\n\tr := bufio.NewReader(bytes.NewBufferString(report))\n\tfor {\n\t\tline, err := r.ReadString('\\n')\n\t\tif err != nil || day >= 31 {\n\t\t\tbreak\n\t\t}\n\n\t\tif y.year == noyear {\n\t\t\t\n\t\t\tif strings.Contains(line, \"for the Moon for \") {\n\t\t\t\ty64, err := strconv.ParseInt(line[80:84], 10, 32)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\ty.year = int(y64)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif y.loc == nil {\n\t\t\tif strings.Contains(line, \"Zone\") {\n\t\t\t\t\n\t\t\t\tz := strings.SplitN(line, \":\", 2)\n\t\t\t\tif len(z) != 2 {\n\t\t\t\t\treturn nil, errFmt(\"zone line\")\n\t\t\t\t}\n\t\t\t\tix := strings.Index(z[1], \"h\")\n\t\t\t\tif ix < 0 {\n\t\t\t\t\treturn nil, errFmt(\"zone is missing the h\")\n\t\t\t\t}\n\t\t\t\thr, err := strconv.ParseFloat(strings.Trim(z[1][0:ix], \" \"), 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, errFmt(err.Error())\n\t\t\t\t}\n\t\t\t\tneg := 1\n\t\t\t\tif strings.Contains(z[1], \"West\") {\n\t\t\t\t\tneg = -1\n\t\t\t\t}\n\t\t\t\ty.loc = time.FixedZone(\"\", neg*int(hr*3600))\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(line, \"Jan.\") ||\n\t\t\tstrings.Contains(line, \"Day Rise\") ||\n\t\t\tstrings.Contains(line, \"h m\") ||\n\t\t\tlen(strings.TrimSpace(line)) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(line) < (4 + 12*11) {\n\t\t\treturn nil, errFmt(\"day line too short\")\n\t\t}\n\n\t\tline = strings.TrimLeft(line, \"\\t\")\n\n\t\t\n\t\tfor mon, pt := 0, 5; mon < 12; mon++ {\n\t\t\trise := line[pt : pt+4]\n\t\t\tset := line[pt+5 : pt+9]\n\t\t\tpt += 11\n\n\t\t\tif rise == \"    \" {\n\t\t\t\ty.months[mon].riseok[day] = false\n\t\t\t} else {\n\t\t\t\th, _ := strconv.ParseInt(rise[0:2], 10, 32)\n\t\t\t\tm, _ := strconv.ParseInt(rise[2:], 10, 32)\n\t\t\t\tr := time.Date(y.year, time.Month(mon+1), day+1, int(h), int(m), 0, 0, y.loc)\n\t\t\t\ty.months[mon].rise[day] = r\n\t\t\t\ty.months[mon].riseok[day] = true\n\t\t\t}\n\t\t\tif set == \"    \" {\n\t\t\t\ty.months[mon].setok[day] = false\n\t\t\t} else {\n\t\t\t\th, _ := strconv.ParseInt(set[0:2], 10, 32)\n\t\t\t\tm, _ := strconv.ParseInt(set[2:], 10, 32)\n\t\t\t\tr := time.Date(y.year, time.Month(mon+1), day+1, int(h), int(m), 0, 0, y.loc)\n\t\t\t\ty.months[mon].set[day] = r\n\t\t\t\ty.months[mon].setok[day] = true\n\t\t\t}\n\t\t}\n\t\tday++\n\t}\n\treturn y, nil\n}\n\nvar zero time.Time\n\nfunc (y *year) Moonrise(tm time.Time) (time.Time, bool) {\n\tif tm.Year() != y.year {\n\t\treturn zero, false\n\t}\n\treturn y.months[tm.Month()-1].rise[tm.Day()-1],\n\t\ty.months[tm.Month()-1].riseok[tm.Day()-1]\n}\n", "entry_point": "read"}
{"task_id": "go_11", "code": "package main\n\nimport \"fmt\"\n\n\nfunc canCompleteCircuit(gas []int, cost []int) int {\n\tif len(gas) == 0 {\n\t\treturn -1\n\t}\n\torigin := make([]int, len(gas))\n\tsum := 0\n\tfor i := range gas {\n\t\torigin[i] = gas[i] - cost[i]\n\t\tsum += origin[i]\n\t}\n\tif sum < 0 {\n\t\treturn -1\n\t}\n\tfor i := 0; i < len(gas); i++ {\n\t\tif origin[i] < 0 {\n\t\t\tcontinue\n\t\t}\n\t\ttmp := origin[i]\n\t\tp := (i + 1) % len(gas)\n\t\tfor p != i {\n\t\t\ttmp += origin[p]\n\t\t\tif tmp < 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp = (p + 1) % len(gas)\n\t\t}\n\t\tif p == i {\n\t\t\treturn i\n\t\t}\n\t\ti = p\n\t}\n\treturn -1\n}\n\nfunc main() {\n\tfmt.Println(canCompleteCircuit([]int{3, 1, 1}, []int{1, 2, 2}))\n}\n", "entry_point": "canCompleteCircuit"}
{"task_id": "go_12", "code": "\npackage day07\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype Node struct {\n\tName        string\n\tWeight      int\n\tSubWeight   int\n\tChildren    []*Node\n\tParentCount int\n}\n\nfunc NewNode(name string) *Node {\n\treturn &Node{\n\t\tName:     name,\n\t\tChildren: make([]*Node, 0),\n\t}\n}\n\n\ntype Graph map[string]*Node\n\n\n\nfunc getBottomProgram(G Graph) *Node {\n\tfor _, node := range G {\n\t\tif node.ParentCount == 0 {\n\t\t\treturn node\n\t\t}\n\t}\n\treturn nil\n}\n\n\n\n\nfunc getCorrectProgramWeight(G Graph) int {\n\troot := getBottomProgram(G)\n\tcomputeSubWeights(root)\n\treturn bfs(root, 0)\n}\n\n\n\n\nfunc computeSubWeights(V *Node) int {\n\tV.SubWeight = V.Weight\n\tfor _, child := range V.Children {\n\t\tV.SubWeight += computeSubWeights(child)\n\t}\n\treturn V.SubWeight\n}\n\n\n\n\nfunc bfs(V *Node, want int) int {\n\ta := make(map[int]int, 0)\n\tb := make(map[int]*Node, 0)\n\tfor _, child := range V.Children {\n\t\ta[child.SubWeight]++\n\t\tb[child.SubWeight] = child\n\t}\n\tif len(a) < 2 {\n\t\treturn V.Weight - (V.SubWeight - want)\n\t}\n\tvar next *Node\n\tfor weight, count := range a {\n\t\tif count == 1 {\n\t\t\tnext = b[weight]\n\t\t} else {\n\t\t\twant = weight\n\t\t}\n\t}\n\treturn bfs(next, want)\n}\n\n\nfunc parseGraph(r io.Reader) (Graph, error) {\n\tG := Graph{}\n\tscanner := bufio.NewScanner(r)\n\tfor scanner.Scan() {\n\t\ttkns := strings.Split(scanner.Text(), \" \")\n\t\tif len(tkns) < 2 {\n\t\t\treturn nil, fmt.Errorf(\"invalid node: %s\", scanner.Text())\n\t\t}\n\n\t\tnode := G[tkns[0]]\n\t\tif node == nil {\n\t\t\tnode = NewNode(tkns[0])\n\t\t\tG[tkns[0]] = node\n\t\t}\n\n\t\tweight := strings.Trim(tkns[1], \"()\")\n\t\tnode.Weight, _ = strconv.Atoi(weight)\n\n\t\tfor i := 3; i < len(tkns); i++ {\n\t\t\tname := strings.TrimRight(tkns[i], \",\")\n\t\t\tchild := G[name]\n\t\t\tif child == nil {\n\t\t\t\tchild = NewNode(name)\n\t\t\t\tG[name] = child\n\t\t\t}\n\t\t\tchild.ParentCount++\n\t\t\tnode.Children = append(node.Children, child)\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn G, nil\n}\n", "entry_point": "parseGraph"}
{"task_id": "go_13", "code": "package worm\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n)\n\n\nfunc GetDirectType(t reflect.Type) reflect.Type {\n\tif t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\treturn t\n}\n\n\nfunc CreateIntArray(arr_ptr interface{}, field string, def_val ...int64) ([]int64, error) {\n\tv_arr := reflect.Indirect(reflect.ValueOf(arr_ptr))\n\tif v_arr.Kind() != reflect.Slice {\n\t\treturn nil, errors.New(\"arr_ptr must be *Slice\")\n\t}\n\tt_item := v_arr.Type().Elem()\n\tif t_item.Kind() != reflect.Struct {\n\t\treturn nil, errors.New(\"array item type muse be reflect.Struct\")\n\t}\n\tfi_info, ok := t_item.FieldByName(field)\n\tif !ok {\n\t\treturn nil, errors.New(\"not find field in struct\")\n\t}\n\n\tvar arr []int64\n\tnum := v_arr.Len()\n\tfor i:=0; i < num; i++ {\n\t\tv_item := v_arr.Index(i)\n\t\tv_ff := v_item.FieldByIndex(fi_info.Index)\n\t\tarr = append(arr, v_ff.Int())\n\t}\n\n\tif len(arr) < 1 && len(def_val) > 0 {\n\t\tarr = append(arr, def_val...)\n\t}\n\n\treturn arr, nil\n}\n\n", "entry_point": "CreateIntArray"}
{"task_id": "go_14", "code": "package tsm1\n\nimport \"io\"\n\n\ntype BitReader struct {\n\tdata []byte\n\n\tbuf struct {\n\t\tv uint64 \n\t\tn uint   \n\t}\n}\n\n\nfunc NewBitReader(data []byte) *BitReader {\n\tb := new(BitReader)\n\tb.Reset(data)\n\treturn b\n}\n\n\nfunc (r *BitReader) Reset(data []byte) {\n\tr.data = data\n\tr.buf.v, r.buf.n = 0, 0\n\tr.readBuf()\n}\n\n\n\n\n\nfunc (r *BitReader) CanReadBitFast() bool { return r.buf.n > 1 }\n\n\n\nfunc (r *BitReader) ReadBitFast() bool {\n\tv := (r.buf.v&(1<<63) != 0)\n\tr.buf.v <<= 1\n\tr.buf.n -= 1\n\treturn v\n}\n\n\nfunc (r *BitReader) ReadBit() (bool, error) {\n\tv, err := r.ReadBits(1)\n\treturn v != 0, err\n}\n\n\nfunc (r *BitReader) ReadBits(nbits uint) (uint64, error) {\n\t\n\tif r.buf.n == 0 {\n\t\treturn 0, io.EOF\n\t}\n\n\t\n\tif nbits <= r.buf.n {\n\t\t\n\t\tif nbits == 64 {\n\t\t\tv := r.buf.v\n\t\t\tr.buf.v, r.buf.n = 0, 0\n\t\t\tr.readBuf()\n\t\t\treturn v, nil\n\t\t}\n\n\t\t\n\t\tv := (r.buf.v >> (64 - nbits))\n\t\tr.buf.v <<= nbits\n\t\tr.buf.n -= nbits\n\n\t\tif r.buf.n == 0 {\n\t\t\tr.readBuf()\n\t\t}\n\t\treturn v, nil\n\t}\n\n\t\n\tv, n := r.buf.v, r.buf.n\n\n\t\n\tr.buf.v, r.buf.n = 0, 0\n\tr.readBuf()\n\n\t\n\tv |= (r.buf.v >> n)\n\tv >>= 64 - nbits\n\n\t\n\tbufN := nbits - n\n\tif bufN > r.buf.n {\n\t\tbufN = r.buf.n\n\t}\n\tr.buf.v <<= bufN\n\tr.buf.n -= bufN\n\n\tif r.buf.n == 0 {\n\t\tr.readBuf()\n\t}\n\n\treturn v, nil\n}\n\nfunc (r *BitReader) readBuf() {\n\t\n\tbyteN := 8 - (r.buf.n / 8)\n\n\t\n\tif n := uint(len(r.data)); byteN > n {\n\t\tbyteN = n\n\t}\n\n\t\n\tif byteN == 8 {\n\t\tr.buf.v = uint64(r.data[7]) | uint64(r.data[6])<<8 |\n\t\t\tuint64(r.data[5])<<16 | uint64(r.data[4])<<24 |\n\t\t\tuint64(r.data[3])<<32 | uint64(r.data[2])<<40 |\n\t\t\tuint64(r.data[1])<<48 | uint64(r.data[0])<<56\n\t\tr.buf.n = 64\n\t\tr.data = r.data[8:]\n\t\treturn\n\t}\n\n\t\n\tfor i := uint(0); i < byteN; i++ {\n\t\tr.buf.n += 8\n\t\tr.buf.v |= uint64(r.data[i]) << (64 - r.buf.n)\n\t}\n\n\t\n\tr.data = r.data[byteN:]\n}\n", "entry_point": "ReadBits"}
{"task_id": "go_15", "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"log\"\n\t\"os\"\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n\ntype Node struct {\n    Name string\n    Nodes []*Node\n    Weight int\n}\n\nfunc getTower(node *Node) int {\n    total := node.Weight\n    for _, n := range node.Nodes {\n        total += getTower(n)\n    }\n    return total\n}\n\nfunc followProblem(node *Node) {\n    var val = 0\n    var other = 0\n\n    fmt.Printf(\"%v children for %v weight %v\\n\", len(node.Nodes), node.Name, node.Weight)\n    var valChild *Node\n    var otherChild *Node\n    nextBad := false\n    for _, child := range node.Nodes {\n        tower := getTower(child)\n        fmt.Printf(\"%v is at %v\\n\", child.Name, tower)\n\n        if nextBad && val != tower {\n            fmt.Printf(\"Majority are %v, this(%v) is %v, weight is %v\\n\", val, child.Name, tower, child.Weight)\n            followProblem(child)\n        } else if val == tower {\n            nextBad = true\n        } else if val == 0 && other == 0 {\n            val = tower\n            valChild = child\n        } else if other == 0 {\n            other = tower\n            otherChild = child\n        } else {\n            if tower == val {\n                fmt.Printf(\"Majority are %v, this(%v) is %v, weight is %v\\n\", val, otherChild.Name, other, otherChild.Weight)\n                followProblem(otherChild)\n                break\n            } else {\n                fmt.Printf(\"Majority are %v, this(%v) is %v, weight is %v\\n\", other, valChild.Name, val, valChild.Weight)\n                followProblem(valChild)\n                break\n            }\n        }\n    }\n}\n\n\nfunc compFunc() {\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Couldn't open file: %v\\n\", err)\n\t}\n\tdefer file.Close()\n\n    tree := make(map[string]*Node)\n    roots := make(map[string]bool)\n    notRoots := make(map[string]bool)\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n        line := scanner.Text()\n        fields := strings.Fields(line)\n        name := fields[0]\n        weightStr := strings.TrimLeft(strings.TrimRight(fields[1], \")\"), \"(\")\n        weight, err := strconv.Atoi(weightStr)\n        if err != nil {\n            log.Fatal(err)\n        }\n\n        if _, ok := tree[name]; !ok {\n            newNode := Node{Name: name}\n            tree[name] = &newNode\n        }\n        node := tree[name]\n        node.Weight = weight\n        if len(fields) > 2 {\n            for i := 3; i < len(fields); i++ {\n                childName := strings.TrimRight(fields[i], \",\")\n                if _, ok := tree[childName]; !ok {\n                    newChild := Node{Name: childName,}\n                    tree[childName] = &newChild\n                }\n                child := tree[childName]\n                node.Nodes = append(node.Nodes, child)\n\n                notRoots[childName] = true\n            }\n            roots[name] = true\n        }\n\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n    var root *Node\n    for k, _ := range roots {\n        if _, present := notRoots[k]; !present {\n            root = tree[k]\n        }\n    }\n\n    fmt.Println(root)\n    followProblem(root)\n}\n\nfunc main() {\n\tcompFunc()\n}\n\n", "entry_point": "compFunc"}
{"task_id": "go_16", "code": "package webcommrsa\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype WebcommRsa struct {\n}\n\n\nfunc encrypt(plainText []byte, pubkey int, modu int) string {\n\tcipherText := \"\"\n\n\tif plen := len(plainText); plen >= 0 {\n\t\tfor x := 0; x < plen; x++ {\n\t\t\tcode := int(plainText[x])\n\t\t\tresult := 0\n\t\t\tmod := 0\n\t\t\thalf := pubkey >> 1\n\n\t\t\tif pubkey%2 == 0 {\n\t\t\t\tresult = 1\n\t\t\t\tfor i := 0; i < half; i++ {\n\t\t\t\t\tmod = (code * code) % modu\n\t\t\t\t\tresult = (mod * result) % modu\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = code % modu\n\n\t\t\t\tfor i := half; i >= 1; i-- {\n\t\t\t\t\tmod = (code * code) % modu\n\t\t\t\t\tresult = (mod * result) % modu\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstrAdd0 := strconv.FormatInt(int64(result), 16)\n\t\t\tadd0In := len(strAdd0)\n\n\t\t\tif add0In <= 4 {\n\t\t\t\tadd0In = 4 - add0In\n\n\t\t\t\tfor i := 0; i < add0In; i++ {\n\t\t\t\t\tstrAdd0 = \"0\" + strAdd0\n\t\t\t\t}\n\t\t\t}\n\t\t\tcipherText += strAdd0\n\t\t}\n\t}\n\n\treturn cipherText\n}\n\nfunc decrypt(cipherText string, prikey int, modu int) []byte {\n\tbsize := len(cipherText)\n\tbyteBuffer := make([]byte, bsize)\n\tj := 0\n\n\tfor x := 0; x < len(cipherText); x += 4 {\n\t\tif c64, err := strconv.ParseInt(cipherText[x:x+4], 16, 32); err == nil {\n\t\t\tresult := 0\n\t\t\thalf := prikey >> 1\n\t\t\tcode := int(c64)\n\n\t\t\tif prikey%2 == 0 {\n\t\t\t\tresult = 1\n\t\t\t\tfor i := 0; i < half; i++ {\n\t\t\t\t\tm := (code * code) % modu\n\t\t\t\t\tresult = (m * result) % modu\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = code % modu\n\t\t\t\tfor i := half; i >= 1; i-- {\n\t\t\t\t\tm := (code * code) % modu\n\t\t\t\t\tresult = (m * result) % modu\n\t\t\t\t}\n\t\t\t}\n\t\t\tbyteBuffer[j] = byte(result)\n\t\t\tj++\n\t\t}\n\t}\n\tplainText := byteBuffer[:j]\n\n\treturn plainText\n}\n\nfunc isPrime(n int) bool {\n\tif n%2 == 0 || n == 1 {\n\t\treturn false\n\t} else {\n\t\tmax := int(math.Floor(math.Sqrt(float64(n))))\n\n\t\tfor i := 3; i <= max; i += 2 {\n\t\t\tif n%i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n}\n\nfunc pickPrime(against int) int {\n\tp := against\n\n\tfor (p == against) || !isPrime(p) {\n\t\tp = 10 + int(math.Floor(rand.Float64()*100.0))\n\t}\n\treturn p\n}\n\nfunc gcd(m, n int) int {\n\tvar x int\n\n\tfor x = m % n; x != 0; x = m % n {\n\t\tm = n\n\t\tn = x\n\t}\n\treturn n\n}\n\nfunc euler(phi, e int) int {\n\tpp := []int{1, 0, 0}\n\tqq := []int{0, 2, 0}\n\trr := []int{e, phi, 0}\n\n\tfor rr[0] != 0 {\n\t\trr[1], rr[2] = rr[0], rr[1]\n\t\tpp[1], pp[2] = pp[0], pp[1]\n\t\tqq[1], qq[2] = qq[0], qq[1]\n\n\t\trr[0] = rr[2] % rr[1]\n\t\tratio := int(math.Floor(float64(rr[2])/float64(rr[1]) + 0.5))\n\t\tpp[0] = ratio*pp[1] + pp[2]\n\t\tqq[0] = ratio*qq[1] + qq[2]\n\t}\n\n\tif result := e*pp[1] - phi*qq[1]; result > 0 {\n\t\treturn pp[1]\n\t} else if pp[1] > 0 {\n\t\treturn phi + pp[1]\n\t} else {\n\t\treturn phi - pp[1]\n\t}\n}\n\nfunc reCrypt(message int, pkey int, modu int) int {\n\tresult := 1\n\thalf := pkey >> 1\n\n\tif pkey%2 == 0 {\n\t\tfor i := half; i > 0; i-- {\n\t\t\tm := (message * message) % modu\n\t\t\tresult = (m * result) % modu\n\t\t}\n\t} else {\n\t\tresult = message % modu\n\n\t\tfor i := half; i >= 1; i-- {\n\t\t\tm := (message * message) % modu\n\t\t\tresult = (m * result) % modu\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc testCrypt(testVal int, rsa []int) bool {\n\tlstrCrypted := reCrypt(testVal, rsa[0], rsa[2])\n\tcompare := reCrypt(lstrCrypted, rsa[1], rsa[2])\n\n\treturn compare == testVal\n}\n\nfunc GenerateKey(message string) ([]int, string) {\n\trand.Seed(time.Now().UTC().UnixNano())\n\n\tfinalFlag := false\n\trsaKey := []int{0, 0, 0}\n\tcipherText := \"\"\n\n\tplainText := []byte(message)\n\n\tfor !finalFlag {\n\t\tfor {\n\t\t\t\n\t\t\tp := pickPrime(2)\n\t\t\tq := pickPrime(p)\n\n\t\t\t\n\t\t\t\n\t\t\tn := p * q\n\t\t\tphi := (p - 1) * (q - 1)\n\t\t\te := n\n\n\t\t\t\n\n\t\t\tfor gcd(e, n) != 1 {\n\t\t\t\te = int(math.Floor(rand.Float64()*float64(phi-2)) + 2)\n\t\t\t\t\n\t\t\t}\n\n\t\t\td := euler(phi, e)\n\n\t\t\trsaKey[0], rsaKey[1], rsaKey[2] = e, d, n\n\n\t\t\tif !(d == 0 || d == 1 || e == d) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif finalFlag = testCrypt(255, rsaKey); finalFlag {\n\t\t\tcipherText = encrypt(plainText, rsaKey[0], rsaKey[2])\n\t\t\tresult := decrypt(cipherText, rsaKey[1], rsaKey[2])\n\n\t\t\tif len(result) != len(plainText) {\n\t\t\t\tfinalFlag = false\n\t\t\t} else {\n\t\t\t\tfor i := 0; i < len(result); i++ {\n\t\t\t\t\tif result[i] != plainText[i] {\n\t\t\t\t\t\tfinalFlag = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn rsaKey, cipherText\n}\n", "entry_point": "encrypt"}
{"task_id": "go_17", "code": "package radix\n\nimport (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\nfunc Sort(a []string) {\n\tn := len(a)\n\tif n < 2 {\n\t\treturn\n\t}\n\tmem := make([]list, n)\n\tfor i, s := range a {\n\t\tmem[i].str = s\n\t\tif i < n-1 {\n\t\t\tmem[i].next = &mem[i+1]\n\t\t}\n\t}\n\tres := msdRadixSort(&mem[0], n)\n\tfor i := range a {\n\t\ta[i] = res.str\n\t\tres = res.next\n\t}\n}\n\n\nfunc SortSlice(slice interface{}, str func(i int) string) {\n\tif slice == nil {\n\t\treturn\n\t}\n\tn := reflect.ValueOf(slice).Len()\n\tif n < 2 {\n\t\treturn\n\t}\n\t\n\tmem := make([]list, n)\n\tfor i := 0; i < n; i++ {\n\t\tmem[i].str = str(i)\n\t\tif i < n-1 {\n\t\t\tmem[i].next = &mem[i+1]\n\t\t}\n\t}\n\tres := msdRadixSort(&mem[0], n)\n\t\n\tperm := make([]int, n)\n\tconst size = unsafe.Sizeof(list{})\n\tbase := uintptr(unsafe.Pointer(&mem[0]))\n\tfor i := 0; i < n; i++ {\n\t\tperm[(uintptr(unsafe.Pointer(res))-base)/size] = i\n\t\tres = res.next\n\t}\n\t\n\tswap := reflect.Swapper(slice)\n\tfor i := 0; i < n; i++ {\n\t\tfor j := perm[i]; j != i; perm[j], j = j, perm[j] {\n\t\t\tswap(i, j)\n\t\t}\n\t}\n}\n\nconst insertBreak = 16\n\ntype list struct {\n\tstr  string\n\tnext *list\n}\n\ntype bucket struct {\n\thead, tail *list\n\tsize       int \n}\n\n\ntype frame struct {\n\thead, tail *list\n\tsize       int \n\tpos        int \n}\n\nfunc msdRadixSort(a *list, n int) *list {\n\tvar res *list\n\tstack := []frame{{head: a, size: n}}\n\tfor len(stack) > 0 {\n\t\ttop := len(stack) - 1\n\t\tframe := stack[top]\n\t\tstack = stack[:top]\n\t\tif frame.size == 0 { \n\t\t\tframe.tail.next = res\n\t\t\tres = frame.head\n\t\t\tcontinue\n\t\t}\n\t\tstack = intoBuckets(stack, frame.head, frame.pos)\n\t}\n\treturn res\n}\n\n\nfunc intoBuckets(stack []frame, a *list, p int) []frame {\n\tvar b0 bucket             \n\tb1 := make([]bucket, 256) \n\tmin, max := 255, 0        \n\n\tt := a\n\tprevCh := -1\n\tif len(t.str) > p {\n\t\tprevCh = int(t.str[p])\n\t}\n\tsize := 1\n\tfor tn := t.next; tn != nil; t, tn = tn, tn.next {\n\t\tch := -1\n\t\tif len(tn.str) > p {\n\t\t\tch = int(tn.str[p])\n\t\t}\n\t\tsize++\n\t\tif ch == prevCh {\n\t\t\tcontinue\n\t\t}\n\t\tif prevCh == -1 {\n\t\t\tintoBucket0(&b0, a, t)\n\t\t} else {\n\t\t\tintoBucket1(&b1[prevCh], a, t, size-1, prevCh, &min, &max)\n\t\t}\n\t\ta = tn\n\t\tprevCh = ch\n\t\tsize = 1\n\t}\n\tif prevCh == -1 {\n\t\tintoBucket0(&b0, a, t)\n\t} else {\n\t\tintoBucket1(&b1[prevCh], a, t, size, prevCh, &min, &max)\n\t}\n\n\tif b0.head != nil {\n\t\tstack = ontoStack(stack, &b0, p)\n\t}\n\tfor ch, n := min, max; ch <= n; ch++ {\n\t\tif b1[ch].head != nil {\n\t\t\tstack = ontoStack(stack, &b1[ch], p+1)\n\t\t}\n\t}\n\treturn stack\n}\n\nfunc intoBucket0(b *bucket, head, tail *list) {\n\tif b.head != nil {\n\t\tb.tail.next = head\n\t\tb.tail = tail\n\t\treturn\n\t}\n\tb.head = head\n\tb.tail = tail\n}\n\nfunc intoBucket1(b *bucket, head, tail *list, size int,\n\tch int, min, max *int) {\n\tif b.head != nil {\n\t\tb.tail.next = head\n\t\tb.tail = tail\n\t\tb.size += size\n\t\treturn\n\t}\n\tb.head = head\n\tb.tail = tail\n\tb.size = size\n\tif ch < *min {\n\t\t*min = ch\n\t}\n\tif ch > *max {\n\t\t*max = ch\n\t}\n}\n\nfunc ontoStack(stack []frame, b *bucket, pos int) []frame {\n\tb.tail.next = nil\n\tif b.size <= insertBreak {\n\t\tif b.size > 1 {\n\t\t\tb.head, b.tail = insertSort(b.head, pos)\n\t\t}\n\t\tb.size = 0 \n\t}\n\n\tif top := len(stack) - 1; top >= 0 && stack[top].size == 0 && b.size == 0 {\n\t\tstack[top].tail.next = b.head\n\t\tstack[top].tail = b.tail\n\t\treturn stack\n\t}\n\tstack = append(stack, frame{\n\t\thead: b.head,\n\t\ttail: b.tail,\n\t\tsize: b.size,\n\t\tpos:  pos,\n\t})\n\treturn stack\n}\n\nfunc insertSort(a *list, p int) (head, tail *list) {\n\thead, tail = a, a\n\tfor r := head.next; r != nil; r = tail.next {\n\t\ts := r.str[p:]\n\t\tswitch {\n\t\tcase tail.str[p:] <= s: \n\t\t\ttail = r\n\t\tcase head.str[p:] >= s: \n\t\t\ttail.next = r.next\n\t\t\tr.next = head\n\t\t\thead = r\n\t\tdefault: \n\t\t\tt := head\n\t\t\tfor t.next.str[p:] <= s {\n\t\t\t\tt = t.next\n\t\t\t}\n\t\t\ttail.next = r.next\n\t\t\tr.next = t.next\n\t\t\tt.next = r\n\t\t}\n\t}\n\treturn\n}\n", "entry_point": "SortSlice"}
{"task_id": "go_18", "code": "package lc\n\nimport \"sort\"\n\n\nfunc minSetSize(arr []int) int {\n\tsort.Ints(arr)\n\n\tcounts := []int{}\n\tcur := 0\n\tfor i := 0; i < len(arr)-1; i++ {\n\t\tcur++\n\t\tif arr[i] != arr[i+1] {\n\t\t\tcounts = append(counts, cur)\n\t\t\tcur = 0\n\t\t}\n\t}\n\n\tif arr[len(arr)-1] != arr[len(arr)-2] {\n\t\tcounts = append(counts, 1)\n\t} else {\n\t\tcur++\n\t\tcounts = append(counts, cur)\n\t}\n\n\tsort.Ints(counts)\n\tvar sum int\n\tvar c int\n\ti := len(counts) - 1\n\tfor sum < len(arr)/2 {\n\t\tsum += counts[i]\n\t\tc++\n\t\ti--\n\t}\n\n\treturn c\n}\n", "entry_point": "minSetSize"}
{"task_id": "go_19", "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage pushid\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar (\n\tlastPushTime int64\n\tlastRandChars []int8\n)\n\nconst (\n\t\n\tPUSH_CHARS string = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\"\n)\n\nfunc init() {\n\tlastRandChars = make([]int8, 12, 12)\n}\n\n\nfunc Generate() (string, error) {\n\tnow := time.Now().UTC().UnixNano() / 1000000\n\tduplicateTime := now == lastPushTime\n\tlastPushTime = now\n\n\ttimeStampChars := make([]string, 8, 8)\n\tfor i := 7; i >= 0; i-- {\n\t\tpcIndex := int64(math.Mod(float64(now), 64.0))\n\t\ttimeStampChars[i] = string(PUSH_CHARS[pcIndex])\n\t\tnow = int64(math.Floor(float64(now) / 64.0))\n\t}\n\n\tif now != 0 {\n\t\treturn \"\", fmt.Errorf(\"We should have converted the entire timestamp.\")\n\t}\n\n\tid := strings.Join(timeStampChars, \"\")\n\n\tif !duplicateTime {\n\t\tfor i := 0; i < 12; i++ {\n\t\t\tlastRandChars[i] = int8(math.Floor(rand.Float64() * 64.0))\n\t\t}\n\t} else {\n\t\tvar i int\n\t\tfor i = 11; i >= 0 && lastRandChars[i] == 63; i-- {\n\t\t\tlastRandChars[i] = 0\n\t\t}\n\n\t\tlastRandChars[i]++\n\t}\n\n\tfor i := 0; i < 12; i++ {\n\t\tid = fmt.Sprintf(\"%s%s\", id, string(PUSH_CHARS[lastRandChars[i]]))\n\t}\n\n\tif len(id) != 20 {\n\t\treturn \"\", fmt.Errorf(\"Length should be 20\")\n\t}\n\n\treturn id, nil\n}\n", "entry_point": "Generate"}
{"task_id": "go_20", "code": "package fifo\n\nconst chunkSize = 64\n\ntype chunk struct {\n\titems       [chunkSize]interface{} \n\tfirst, last int                    \n\tnext        *chunk                 \n}\n\n\ntype UnsafeQueue struct {\n\thead, tail *chunk \n\tcount      int    \n}\n\n\nfunc NewUnsafeQueue() (q *UnsafeQueue) {\n\tinitChunk := new(chunk)\n\tq = &UnsafeQueue{\n\t\thead: initChunk,\n\t\ttail: initChunk,\n\t}\n\treturn q\n}\n\n\nfunc (q *UnsafeQueue) Len() (length int) {\n\t\n\tlength = q.count\n\treturn length\n}\n\n\nfunc (q *UnsafeQueue) Add(item interface{}) {\n\t\n\tif item == nil {\n\t\tpanic(\"can not add nil item to fifo queue\")\n\t}\n\n\t\n\tif q.tail.last >= chunkSize {\n\t\tq.tail.next = new(chunk)\n\t\tq.tail = q.tail.next\n\t}\n\n\t\n\tq.tail.items[q.tail.last] = item\n\tq.tail.last++\n\tq.count++\n}\n\n\nfunc (q *UnsafeQueue) AddList(items []interface{}) {\n\t\n\tif len(items) == 0 {\n\t\t\n\t\treturn\n\t}\n\t\n\tif len(items) > chunkSize { \n\t\tchunks := len(items) / chunkSize\n\t\tif chunks*chunkSize != len(items) { \n\t\t\tchunks++\n\t\t}\n\n\t\tfor i := 0; i < chunks; i++ {\n\t\t\ts := i * chunkSize\n\t\t\te := (i + 1) * chunkSize\n\n\t\t\tif e > len(items) {\n\t\t\t\te = len(items)\n\t\t\t}\n\n\t\t\tq.AddList(items[s:e])\n\t\t}\n\t\treturn\n\t}\n\n\t\n\tif q.tail.last >= chunkSize {\n\t\tq.tail.next = new(chunk)\n\t\tq.tail = q.tail.next\n\t}\n\n\ts := q.tail.last\n\te := len(items) - s\n\tn := copy(q.tail.items[s:e], items)\n\tq.tail.last += n\n\tq.count += n\n\titems = items[e:]\n\n\tif len(items) > 0 {\n\t\tq.AddList(items) \n\t}\n}\n\n\nfunc (q *UnsafeQueue) NextN(n int) []interface{} {\n\tif n > chunkSize {\n\t\t\n\t\tchunks := n / chunkSize\n\t\tif chunks*chunkSize < n {\n\t\t\tchunks++\n\t\t}\n\n\t\tout := make([]interface{}, 0)\n\t\tread := 0\n\t\tfor i := 0; i < chunks; i++ {\n\t\t\te := chunkSize\n\t\t\tif read+e > n {\n\t\t\t\te = n - read\n\t\t\t}\n\n\t\t\tout = append(out, q.NextN(e)...)\n\t\t}\n\t\treturn out\n\t}\n\n\tif q.count < n {\n\t\tn = q.count \n\t}\n\n\tif q.count == 0 || q.head.first >= q.head.last {\n\t\treturn make([]interface{}, 0)\n\t}\n\n\t\n\tout := make([]interface{}, n)\n\n\tread := 0\n\tfor i := 0; i < n; i++ {\n\t\tif q.count == 0 {\n\t\t\tbreak\n\t\t}\n\t\tread++\n\t\tout[i] = q.Next()\n\t}\n\n\treturn out[:read]\n}\n\n\nfunc (q *UnsafeQueue) Next() (item interface{}) {\n\n\t\n\tif q.count == 0 {\n\t\treturn nil\n\t}\n\t\n\tif q.head.first >= q.head.last {\n\t\treturn nil\n\t}\n\n\t\n\titem = q.head.items[q.head.first]\n\n\t\n\tq.head.first++\n\tq.count--\n\n\tif q.head.first >= q.head.last {\n\t\t\n\t\t\n\t\tif q.count == 0 {\n\t\t\tq.head.first = 0\n\t\t\tq.head.last = 0\n\t\t\tq.head.next = nil\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\tq.head = q.head.next\n\t\t}\n\t}\n\n\t\n\treturn item\n}\n\n\n\nfunc (q *UnsafeQueue) Peek() (item interface{}) {\n\t\n\tif q.count == 0 {\n\t\treturn nil\n\t}\n\t\n\tif q.head.first >= q.head.last {\n\t\treturn nil\n\t}\n\n\t\n\treturn q.head.items[q.head.first]\n}\n", "entry_point": "NextN"}
